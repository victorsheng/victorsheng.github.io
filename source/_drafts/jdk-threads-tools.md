---
title: jdk-threads-tools
abbrlink: 323138820
tags:
categories:
---


01、Semaphore划重点



What：Semaphore主要用于控制同时访问特定资源的线程数量，它通过协调各个线程，始终保持一定数量内的线程去使用公共资源。



How：可以认为Semaphore是对锁的扩展。从概念上来讲，Semaphore维护了一个许可集合，集合的数量有限，其中集合中的元素就是一个许可，线程拿到许可，就好比是拿到了线程执行的“通行证”可以立即被执行。如果某个线程试图去从空集合中去取许可，那么就会自动阻塞；而某个线程执行完毕后，需要主动把许可归还入集合，唤醒被阻塞的线程，同时保证了线程最大并发执行数始终控制在许可集合的数目内。



Why：Semaphore常用于做流量控制，特别是排队访问公用资源有限的应用场景，比如线程池、网络连接池、数据库连接池等。



02、CountDownLatch划重点



What：CountDownLatch是一个同步控制工具类，也称为同步计数器。其作用在于：在完成一组正在其他线程中执行的操作之前，它允许一个或多个线程一直等待。



How：用给定的计数初始化CountDownLatch，如果想等待K个工作完成，在构造函数中就传入初始计数K。调用了countDown()方法，其计数会减少1，在当前计数到达零之前，await()方法会一直受阻塞。一旦计数减少到零之后，会唤醒所有等待的线程，await的所有后续调用都将立即返回。



Why：基于CountDownLatch的特性，其主要用于线程间的条件等待：

应用场景1：启动了10个多线程去下载文件，当10个线程都执行完成了才标识下载成功。

应用场景2：采用多线程上传多个文件，当所有文件都上传成功了才标识上传成功。

应用场景3：火箭发射前有N个检查项，只有N个检查完成了并正确无误，才能进行后续的火箭发射操作。



03、Exchanger划重点



What：Exchanger是一个用于线程间协作工具类；可在两个线程之间交换数据，并仅限于2个线程之间，不支持更多的线程之间互换数据。



How：Exchanger提供一个同步点，在这个同步点，两个线程可以交换彼此的数据。当线程A调用Exchange对象的exchange()方法后，它会陷入阻塞状态，直到线程B也调用了exchange()方法，此刻表示两个线程都达到了同步点，然后两个线程就会以线程安全的方式进行数据交换，数据交换完成后，线程A和B继续各自运行。



Why：基于Exchanger的特性，其主要用于两个线程在同步点互换数据：

应用场景1：Exchanger可用于遗传算法。遗传算法中需要选出两个元素作为交配对象，这时候会交换两者的数据，并使用交叉规则得出2个交配结果。

应用场景2：Exchange可用于校对工作，在一些重要场景（如银行对账），为了避免错误，可安排A、B两个线程分别做同一任务，然后在一个同步点互换数据，进行数据对比，看双方的结果数据是否一致。

应用场景3：Exchange可用于解决一对一的生产者-消费者问题。



04、CyclicBarrier划重点



What：CyclicBarrier是另外一个多线程并发同步辅助类。它允许一组线程相互等待，直到该组内的所有线程都到达某个公共barrier点，然后所有的这组线程再同步往后面执行。



How：CyclicBarrier类的await()方法是该工具类的核心方法。该方法每被调用一次，内部计数器（初始计数器的值就是需要同步的一组线程的数目）便会减少1，并阻塞当前线程。当计数减少到0时，所有在此CyclicBarrier所阻塞线程被唤醒开始运行。在此之后，可再次调用await()方法，计数就又会变成N-1，新一轮重新开始。



Why：基于CyclicBarrie的特性，其主要用于线程间的条件等待；可以用于在处理一些复杂大型任务时，常采用“分而治之”的思想将大任务分解为多个子任务去执行，只有当所有子任务都执行完成时，才能执行主任务。



05、LockSupport划重点



What：LockSupport定义了一组公共静态方法，这些方法提供了最基本的线程阻塞和唤醒功能；此外，LockSupport也是构建Java同步组件的基础设施。



How：LockSupport工具类可以在线程内任意位置让线程安全阻塞。和Thread.suspend()相比，它弥补了由于resume()在前发生，导致线程无法继续执行的情况。此外，同Object.wait()方法比较，它不需要先获取某个对象的锁，也不会抛出InterruptedException异常。



Why：凡是需要实现线程间的安全阻塞与唤醒功能的业务场景均可应用。


06、Phaser划重点



What：Phaser是一个更强大的、更复杂的同步辅助类，可以完全覆盖CyclicBarrier、CountDownLatch工具栏的功能，但是比他们更强大、更加灵活。 



How：当一个任务被分解成了多个步骤，Phaser类机制是在每一步骤结束的位置对线程进行同步，当所有的线程都完成了这一步骤，才能继续进行下一步骤。 当我们有并发任务并且需要将任务分解成多个步骤执行的时候，这种Phaser机制就非常适合。 



Why：适用于有并发任务并且需要将任务分解成多个步骤执行的业务场景。


# 参考
https://mp.weixin.qq.com/s/nVqbRlmMK-vQdiK6_xfTsw