---
title: 字段访问相关优化
date: 2018-09-17 09:24:36
tags:
categories:
---
# 回顾(不会逃逸的情况)
基于逃逸分析的优化方式锁消除、栈上分配以及标量替换等内容。
其中的标量替换，可以看成将对象本身拆散为一个个字段，并把原本对对象字段的访问，替换为对一个个局部变量的访问。

```
class Foo {
  int a = 0;
}

static int bar(int x) {
  Foo foo = new Foo();
  foo.a = x;
  return foo.a;
}
```

举个例子，上面这段代码中的bar方法，**经过逃逸分析以及标量替换后**，其优化结果如下所示。（确切地说，是指所生成的 IR 图与下述代码所生成的 IR 图类似。之后不再重复解释。）
```
static int bar(int x) {
  int a = x;
  return a;
}
```
由于 Sea-of-Nodes IR 的特性，局部变量不复存在，取而代之的是一个个值。在例子对应的 IR 图中，返回节点将直接返回所输入的参数。


# 真实逃逸的情况or因为方法内联不够彻底而被即时编译器当成是逃逸的 --两种优化方式
```
static int bar(Foo o, int x) {
  o.a = x;
  return o.a;
}
```

在上面这段代码中，对象o是传入参数， **不属于逃逸分析的范围（Java 虚拟机中的逃逸分析针对的是新建对象）**。该方法会将所传入的 int 型参数x的值存储至实例字段Foo.a中，然后再读取并返回同一字段的值。
这段代码将涉及两次内存访问操作：存储以及读取实例字段Foo.a。我们可以轻易地将其手工优化为直接读取并返回传入参数 x 的值。由于这段代码较为简单，因此它极大可能被编译为寄存器之间的移动指令（即将输入参数x的值移至寄存器 eax 中）。这与原本的内存访问指令相比，显然要高效得多。

```
static int bar(Foo o, int x) {
  o.a = x;
  return x;
}
```
那么即时编译器是否能够作出类似的自动优化呢？
## 字段读取优化（缓存）
**即时编译器会优化实例字段以及静态字段访问，以减少总的内存访问数目。具体来说，它将沿着控制流，缓存各个字段存储节点将要存储的值，或者字段读取节点所得到的值。**

- 当即时编译器遇到对 **同一字段的读取节点时**，如果缓存值还没有失效，那么它会将读取节点替换为该缓存值。
- 当即时编译器遇到对 **同一字段的存储节点时**，它会更新所缓存的值。
- 当即时编译器遇到 **可能更新字段的节点时，如方法调用节点（在即时编译器看来，方法调用会执行未知代码），或者内存屏障节点（其他线程可能异步更新了字段）**，那么它会采取保守的策略，舍弃所有缓存值。


### volatile
在介绍 Java 内存模型时，我们便知道可以通过 volatile 关键字标记实例字段a，以此强制对它的读取。
实际上，即时编译器将在 volatile 字段访问前后插入内存屏障节点。这些内存屏障节点会阻止即时编译器将屏障之前所缓存的值用于屏障之后的读取节点之上。
就我们的例子而言，尽管在 X86_64 平台上，volatile 字段读取操作前后的内存屏障是 no-op，在即时编译过程中的屏障节点，还是会阻止即时编译器的字段读取优化，强制在循环中使用内存读取指令访问实例字段Foo.a的最新值。

同理，加锁、解锁操作也同样会阻止即时编译器的字段读取优化。

## 字段存储优化
即时编译器还将消除冗余的存储节点。如果一个字段先后被存储了两次，而且这两次存储之间没有对第一次存储内容的读取，那么即时编译器可以将第一个字段存储给消除掉。
```
class Foo {
  int a = 0;
  void bar() {
    a = 1;
    a = 2;
  }
}
```
举例来说，上面这段代码中的bar方法先后存储了两次Foo.a实例字段。由于第一次存储之后没有读取Foo.a的值，因此，即时编译器会将其看成冗余存储，并将之消除掉

即便是在这两个字段存储操作之间读取该字段，即时编译器还是有可能在字段读取优化的帮助下，将第一个存储操作当成冗余存储给消除掉。

当然，如果所存储的字段被标记为 volatile，那么即时编译器也不能将冗余的存储操作消除掉。
这种情况看似很蠢，但实际上并不少见，比如说两个存储之间隔着许多其他代码，或者因为方法内联的缘故，将两个存储操作（如构造器中字段的初始化以及随后的更新）纳入同一个编译单元里。

# 死代码消除
## 死存储
除了字段存储优化之外，局部变量的死存储（dead store）同样也涉及了冗余存储。这是死代码消除（dead code eliminiation）的一种。不过，由于 Sea-of-Nodes IR 的特性，死存储的优化无须额外代价。

```
int bar(int x, int y) {
  int t = x*y;
  t = x+y;
  return t;
}
```

上面这段代码涉及两个存储局部变量操作。当即时编译器将其转换为 Sea-of-Nodes IR 之后，没有节点依赖于 t 的第一个值x*y。因此，该乘法运算将被消除


## 冗余存储
死存储还有一种变体，即在部分程序路径上有冗余存储。

```
int bar(boolean f, int x, int y) {
  int t = x*y;
  if (f)
    t = x+y;
  return t;
}
```

## 不可达分支
另一种死代码消除则是不可达分支消除。


# 总结与实践
今天我介绍了即时编译器关于字段访问的优化方式，以及死代码消除。
即时编译器将沿着控制流缓存字段存储、读取的值，并在接下来的字段读取操作时直接使用该缓存值。
这要求生成缓存值的访问以及使用缓存值的读取之间没有方法调用、内存屏障，或者其他可能存储该字段的节点。
即时编译器还会优化冗余的字段存储操作。如果一个字段的两次存储之间没有对该字段的读取操作、方法调用以及内存屏障，那么即时编译器可以将第一个冗余的存储操作给消除掉。

此外，我还介绍了死代码消除的两种形式。第一种是局部变量的死存储消除以及部分死存储消除。它们可以通过转换为 Sea-of-Nodes IR 来完成。第二种则是不可达分支。通过消除不可达分支，即时编译器可以精简数据流，并且减少编译时间以及最终生成机器码的大小。










