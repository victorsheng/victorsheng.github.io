---

title: "Redis 快的原因"
date: "2018-03-26 18:21"
---
R
edis 采用的是基于内存的采用的是单进程单线程模型的 KV 数据库，由 C 语言编写。官方提供的数据是可以达到100000+的 qps。这个数据不比采用单进程多线程的同样基于内存的 KV 数据库 Memcached 差。

Redis 快的主要原因有：

1. 完全基于内存；
2. 数据结构简单，对数据操作也简单；
3. 使用多路 I/O 复用模型；

第一、二点不细讲，主要围绕第三点采用多路 I/O 复用技术来展开。

多路 I/O 复用模型是利用 select、poll、epoll 可以**同时监察多个流的 I/O 事件**的能力，在空闲的时候，会把当前线程阻塞掉，当有一个或多个流有 I/O 事件时，就从阻塞态中唤醒，于是程序就会轮询一遍所有的流（epoll 是只轮询那些真正发出了事件的流），并且只依次顺序的处理就绪的流，这种做法就避免了大量的无用操作。这里“多路”指的是多个网络连接，“复用”指的是复用同一个线程。采用多路 I/O 复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络 IO 的时间消耗），且 Redis 在内存中操作数据的速度非常快（内存内的操作不会成为这里的性能瓶颈），主要以上两点造就了 Redis 具有很高的吞吐量。

![](http://www.syyong.com/usr/uploads/2016/07/3587411016.png)

和 Memcached 不同，Redis 并没有直接使用 Libevent，而是自己完成了一个非常轻量级的对 select、epoll、evport、kqueue 这些通用的接口的实现。在不同的系统调用选用适合的接口，linux 下默认是 epoll。因为 Libevent 比较重，更通用，代码量也就很庞大，拥有很多 Redis 用不上的功能，Redis 为了追求“轻巧”并且去除依赖，就选择自己去封装了一套。

### 单进程单线程好处

1. 代码更清晰，处理逻辑更简单
2. 不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗
3. 不存在多进程或者多线程导致的切换而消耗 CPU

### 单进程单线程弊端

1. 无法发挥多核 CPU 性能，不过可以通过在单机开多个 Redis 实例来完善；

### 其他一些优秀的开源软件采用的模型

* 多进程单线程模型：Nginx
* 单进程多线程模型：Memcached
