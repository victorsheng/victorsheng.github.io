---
title: 布隆过滤器
abbrlink: 2583914988
date: 2018-11-04 19:05:20
tags:
categories:
---
# 整体流程
假设，bit 类型数组的长度为 m，每个元素值为 0，有 k 个哈希函数。

首先，当输入一个 url 的时候，此时这个 url 会经过 k 个哈希函数处理，得到多个哈希值（v1,v2,...,vk）。之后分别将这些哈希值除以数组的长度 m，和对 m 取模，得到这些哈希值对应在数组的下标位置，最后将这些下标的元素都置为 1。

那么如何判断一个 url 在黑名单里面呢？输入一条 url，它经过上述处理之后，会得到多个数组的下标位置。如果这些下标的元素值都已经为 1 了，说明该在黑名单里面，否则不在。

# 实现
总体就是这样的流程，下面说下大家可能存在的疑问：
1、bit 类型的数组如何构建
2、得到 v1,v2,...,vk 这些哈希值后，如何得到其在数组的下标位置，并将其设置为 1 呢？

## 用int数组进程存储
```
//创建了一个 100 * 32bit 的数组
int[] arr = new int[100]; 
// 代表 bit 数组 0-31 位的元素
arr[0];
```

## setbit位

```
void Set(int data) {
       // ByteNO 是表示在 table 数组中那个元素
       int ByteNo = data / 100;
       // bitNo 是表示在 32 位 bit 中哪个 bit 位。
       int BitNo = data % 32;
       // 置 1
       _table[ByteNo] |= (1 << BitNo); 
   }
```

# 内存占用公式
内存占用公式 m = -(n*lnP)/(ln2)²（其中 n 为 100 亿，P 为 0.0001），由此计算出约等于 2000 亿 bit，约等于 23GB。

# 优缺点
它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。


# Counting Bloom Filter
从前面几篇对Bloom Filter的介绍可以看出，标准的Bloom Filter是一种很简单的数据结构，它只支持插入和查找两种操作。在所要表达的集合是静态集合的时候，标准Bloom Filter可以很好地工作，但是如果要表达的集合经常变动，标准Bloom Filter的弊端就显现出来了，因为它不支持删除操作。


 

Counting Bloom Filter的出现解决了这个问题，它将标准Bloom Filter位数组的每一位扩展为一个小的计数器（Counter），在插入元素时给对应的k（k为哈希函数个数）个Counter的值分别加1，删除元素时给对应的k个Counter的值分别减1。Counting Bloom Filter通过多占用几倍的存储空间的代价，给Bloom Filter增加了删除操作。


