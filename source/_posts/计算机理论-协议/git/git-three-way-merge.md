---
title: git代码和并
abbrlink: 199971790
date: 2018-12-12 11:02:26
tags:
categories:
---

**问:git代码和并是用时间先后决定merge结果的，后面会覆盖前面的?**

答 ：git 是分布式的文件版本控制系统，在分布式环境中时间是不可靠的，git是靠three-way-merge算法进行合并的。

# two-way-merge
假设我们正在同时修改同一个文件。你去对文件做一些更改然后我做了一些更改。

在某个时间点，有人查看文件的两个副本，他们看到如图1所示的内容：
![](http://twimgs.com/ddj/images/article/2013/1213/Merge1.gif)

第三个查看文件的人看到第30行有区别但是：

他如何判断你是否修改了第30行或是否修改了它？
如果我们都修改了这条线怎么办？他怎么能说出来？
他不能。

他将不得不打电话给我们两个人并相信我们的记忆，找出谁修改了什么。是的，幸运的是我们程序员永远不会忘记，对吧？;-)

这个“第三人”可能实际上是试图进行简单的双向合并的版本控制系统，它只是比较文件的两个版本并尝试合并它们。但在这里，VCS将需要用户干预，因为它无法弄清楚该怎么做。

如果必须依赖双向合并，最好避免对文件进行并发修改，因为这将是一个缓慢的手动过程。想象一下需要简单合并的300个文件......这需要很长时间才能完成！

# three-way-merge自动合并

让我们忘记关于版本控制的第二个问题，然后回到这个“第三人”，查看我们修改过的两个文件：他怎么能弄清楚自己发生了什么？

他可以查看我们用作起点的文件的原始版本（图2）：

![](http://twimgs.com/ddj/images/article/2013/1213/Merge2.gif)

然后，看看文件最初是如何（“基础共同祖先”或简称“基础”），他可以找出该做什么。

根据图2，只有一个开发人员实际更改了第30行，因此可以手动解决冲突：只需保留“你的”作为解决方案，所以它会说： Print("hello");

这就是三向合并的帮助：它将手动冲突转变为自动解决方案。这里的部分魔力依赖于VCS定位文件的原始版本。这个原始版本被称为“最近的共同祖先”。然后，VCS将共同的祖先和两个贡献者传递给三向合并工具，该工具将使用所有三个来计算结果。

仅使用双向合并，由两个开发人员修改的行将需要手动干预，而其他所有行将自动合并。通过三向合并，可以运行涉及数百个文件的无痛合并。


# three-way-merge手动合并场景

现在让我们检查一个稍微复杂的案例，如图3所示：
![](http://twimgs.com/ddj/images/article/2013/1213/Merge3.gif)

将这两个文件并排比较，我们可以看到有三行有差异：

- 第30行：与之前的冲突相同。
- 第51行：for修改循环。
- 第70行：我们不知道“你的”是否删除了一些代码或“我的”添加了它。


![](http://twimgs.com/ddj/images/article/2013/1213/Merge4.gif)

现在让我们看看能够正确解决冲突的共同祖先（图4）：

- 第30行的冲突可以自动解决，“你的”（来源贡献者）将被保留，因为只有一个贡献者被修改。
- 第70行的冲突也可以自动解决为“我的”（目的地贡献者），因为现在很清楚该行已被添加并且之前不存在。
- 第51行的冲突需要手动解决：您需要决定是要保留其中一个贡献者，另一个，还是手动修改它。
这基本上是三方合并的方式。

# 翻译原文
http://www.drdobbs.com/tools/three-way-merging-a-look-under-the-hood/240164902