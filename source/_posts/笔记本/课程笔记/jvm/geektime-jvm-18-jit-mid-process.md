---
title: geektime-jvm-18-jit-mid-process
abbrlink: 1590151434
date: 2018-08-31 21:14:22
tags:
categories:
---
# 1. 中间表达形式（IR）(Intermediate Representation)

在编译原理课程中，我们通常将编译器分为前端和后端。
- 其中，前端会对所输入的程序进行词法分析、语法分析、语义分析，然后生成中间表达形式，也就是 IR（Intermediate Representation ）。
- 后端会对 IR 进行优化，然后生成目标代码。



如果不考虑解释执行的话，从 Java 源代码到最终的机器码实际上经过了两轮编译：
- Java 编译器将 Java 源代码编译成 Java 字节码，而即时编译器则将 Java 字节码编译成机器码。
- 对于即时编译器来说，所输入的 Java 字节码剥离了很多高级的 Java 语法，而且其采用的基于栈的计算模型非常容易建模。因此，即时编译器并不需要重新进行词法分析、语法分析以及语义分析，而是直接将 Java 字节码作为一种 IR。

不过，Java 字节码本身并不适合直接作为可供优化的 IR。这是因为现代编译器一般采  **用静态单赋值（Static Single Assignment，SSA）IR**。这种 IR 的特点是每个变量只能被赋值一次，而且只有当变量被赋值之后才能使用。


- 常量折叠（constant folding）:x1=4*1024 经过常量折叠后变为 x1=4096
- 常量传播（constant propagation）:经过常量传播后变为 x1=4; y1=4
- 强度削减（strength reduction）:经过强度削减后变为 y1=(x1<<1)+x1
- 死代码删除（dead code elimination）:经过死代码删除后变为 y1=1


部分同学可能会手动进行上述优化，以期望能够达到更高的运行效率。实际上，对于这些简单的优化，编译器会代为执行，以便程序员专注于代码的可读性。


## Phi函数

```
x = ..;
if (x > 0) {
  y = 0;
} else {
  y = 1;
}
x = y;
```
SSA IR 会带来一个问题，那便是不同执行路径可能会对同一变量设置不同的值。例如下面这段代码 if 语句的两个分支中，变量 y 分别被赋值为 0 或 1，并且在接下来的代码中读取 y 的值。此时，根据不同的执行路径，所读取到的值也很有可能不同。

为了解决这个问题，我们需要引入一个 Phi 函数的概念，能够根据不同的执行路径选择不同的值。于是，上面这段代码便可以转换为下面这段 SSA 伪代码。这里的 Phi 函数将根据前面两个分支分别选择 y1、y2 的值，并赋值给 y3。

```
x1 = ..;
if (x1 > 0) {
  y1 = 0;
} else {
  y2 = 1;
}
y3 = Phi(y1, y2);
x2 = y3;
```


总之，即时编译器会将 Java 字节码转换成 SSA IR。更确切的说，是一张包含控制流和数据流的 IR 图，每个字节码对应其中的若干个节点（注意，有些字节码并没有对应的 IR 节点）。然后，即时编译器在 IR 图上面进行优化。
我们可以将每一种优化看成一个独立的图算法，它接收一个 IR 图，并输出经过转换后的 IR 图。整个编译器优化过程便是一个个优化串联起来的。




# 2. Sea-of-nodes
HotSpot 里的 C2 采用的是一种名为 Sea-of-Nodes 的 SSA IR。**它的最大特点，便是去除了变量的概念，直接采用变量所指向的值，来进行运算。**







# 总结与实践

即时编译器将所输入的 Java 字节码转换成 SSA IR，以便更好地进行优化。

具体来说，C2 和 Graal 采用的是一种名为 Sea-of-Nodes 的 IR，其特点用 IR 节点来代表程序中的值，并且将源程序中基于变量的计算转换为基于值的计算。

此外，我还介绍了 C2 和 Graal 的 IR 的可视化工具 IGV，以及基于 IR 的优化 GVN。