---
title: aliyun-match-sumary
abbrlink: 324504186
date: 2018-07-30 19:51:23
tags:
categories:
---









请教各位大佬一个问题，不知道有没有人研究对比过 netty 引入的 jcTool 无锁队列（MpscQueue，MpMcQueue 这些） 以及 Disruptor 的 RingBuffer 实现，同样也是内存中的无锁队列。有没有对他们做过源码研究以及性能对比的，他们的使用场景有何不同。



CTool是类库，disruptor是并发框架。disruptor很灵活，使用disruptor可以开发出很复杂的并发处理流程。但使用disruptor要按disruptor的编程模式来进行编程，刚使用disruptor时可能会觉得不习惯。JCTool的使用方式更接近BlockingQueue的使用方式，如果只是实现生产者和消费者之间高效的交换数据使用JCTool会简单一点。
JCTool和disruptor都使用了缓存行填充避免伪共享以及使用CAS实现无锁算法的技术（事实上有人同时是这两个项目的代码提交者）。另外disruptor的ring buffer上的对象是复用的，这有效的避免重复生成对象减轻gc压力从而提升应用程序的性能；在disruptor里多个consumer之间不存在竞争；在disruptor 里可以通过批量生产及消费数据来提高吞吐量。
伪共享是并发程序的性能杀手，我很奇怪为什么在这里从来听到有人提过针对这个点而进行的性能优化；相反很多人都认为一次内存的复制成本很高，事实上以4k为单位的内存复制的成本并没有想象中那么高。这是因为内存的带宽可以达到5､6g以及cpu 高速缓存预读和使用xmm这些寄存器（可能是cpu太旧在JIT生成的汇编代码中没看到使用zmm、ymm这些寄存器）的缘故，在我的4c笔记本上测试以4k为单位多复制一次100g的数据增加的时间不到20秒。







感谢答疑，这几天每天都会打开钉钉看看有没有人回复我的问题，这样的疑问是由于比赛中的某些思路需要用到内存队列，而 Jdk 自带的内存队列并发性能都不高导致的。在赛后系统的梳理了一下“高性能内存队列”这样的知识点，能够搜索到的现成资料并不多，我做了一些总结，不妨也跟各位分享下。

首先被我找到的是 Netty 使用的 JCTool，将单/多 生产者/消费者的排列组合区分成了 Spsc Mpsc SpMc Mpmc ，这样的无锁内存队列经过本地的压测，各种场景下，各种并发量级的性能几乎都是 ArrayBlockingQueue,LinkedBlockingQueue 的 10 倍有余，这和 JCTool 所做的无锁算法设计以及缓存行 Padding 避免伪共享有关。随后，我希望找到一款能够限制内存使用量的队列，尤其是复赛这种限定了内存使用量的场景，内存的控制尤为重要，于是 RingBuffer 这个数据结构进入了我视野，顺理成章的研究了下 RingBuffer 的 Java 鼻祖-Disrutor 这款框架，他和 JCTool 的原理有很多的相似之处，并且正如 hua88 所言，Disrutor 更倾向于开发复杂的并发处理流程，需要按照其特定的编程模型来进行编程，所以说使用 Disrutor 内部的数据结构 RIngBuffer 来和 JCTool 的几个Queue 做对比可能更加合适，Ringbuffer 在实现了缓存行填充以及无锁设计的同时，使用预先分配好的对象进行了 Buffer填充，这有效的复用了对象，是 GC 友好的，同时环形缓冲区的设计可以精准的控制好内存使用量,这一点设计思路来源于 @王亚普 的方案，的确是行之有效的方案。

我得出的结论便是：类似于复赛的场景下 RIngBuffer 优秀。JCTool 实现了优秀高效的的内存队列，如果仅仅需要使用内存队列这样的数据结构 JCTool 非常合适；Disruptor 是一款优秀高效的事件驱动框架，如果在项目设计中需要使用高效的事件驱动模型，其是一个不错的选择，这也是经过不少实践验证的：log4j，部分游戏框架，以及我从朋友那儿请教后得知陆金所的交易数据处理都用到了 Disruptor。Disruptor 的性能测试可以看这里：https://tech.meituan.com/disruptor.html

回复hua88的几个观点：
1 伪共享是并发程序的性能杀手，我很奇怪为什么在这里从来听到有人提过针对这个点而进行的性能优化？
我：并非没有提到，很多人都意识到了 Cpu Cache 以及 Cache Line的存在，可能是受限于篇幅没有单独列出来， in fact 我专门总结了一下这个概念：https://www.cnkirito.moe/cache-line/ 。 另外缓存行填充的确可以很好的利用好 cpu 多级缓存的特性，但 padding 也会加大内存的使用量，cache line vs
more ram use 的 trade off 我并不能准确的判断出优劣。

2 很多人都认为一次内存的复制成本很高，事实上以4k为单位的内存复制的成本并没有想象中那么高
我：会不会是由于本地内存较为宽裕的情况导致了这样的差距较小呢？以我目前的理解来看，减少内存拷贝不仅仅是速度的差距，还涉及到内存使用量的因素。



