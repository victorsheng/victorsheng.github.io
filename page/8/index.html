<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="victor的个人博客,作为一枚后端开发工程师,写本博客目的,旨在记录自己在工作生活中的点点滴滴,形成自己的知识体系">
<meta property="og:type" content="website">
<meta property="og:title" content="Victor的博客">
<meta property="og:url" content="http://yoursite.com/page/8/index.html">
<meta property="og:site_name" content="Victor的博客">
<meta property="og:description" content="victor的个人博客,作为一枚后端开发工程师,写本博客目的,旨在记录自己在工作生活中的点点滴滴,形成自己的知识体系">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Victor的博客">
<meta name="twitter:description" content="victor的个人博客,作为一枚后端开发工程师,写本博客目的,旨在记录自己在工作生活中的点点滴滴,形成自己的知识体系">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/8/"/>





  <title>Victor的博客</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?2342180055c7117a644c0e88269f1028";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Victor的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-schedule">
          <a href="/schedule/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-calendar"></i> <br />
            
            日程表
          </a>
        </li>
      
        
        <li class="menu-item menu-item-sitemap">
          <a href="/sitemap.xml" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br />
            
            站点地图
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/20/运维/study-nginx-statistics/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Victor">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Victor的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/20/运维/study-nginx-statistics/" itemprop="url">study-nginx-statistics</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-20T14:02:25+08:00">
                2018-03-20
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/03/20/运维/study-nginx-statistics/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/03/20/运维/study-nginx-statistics/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2018/03/20/运维/study-nginx-statistics/" class="leancloud_visitors" data-flag-title="study-nginx-statistics">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>根据nginx日志,查询访问最频繁的IP</p>
<p>1.根据访问IP统计UV<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk &apos;&#123;print $1&#125;&apos;  /var/log/nginx/access.log|sort | uniq -c |wc -l</span><br></pre></td></tr></table></figure></p>
<p>2.统计访问URL统计PV<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk &apos;&#123;print $7&#125;&apos; /var/log/nginx/access.log|wc -l</span><br></pre></td></tr></table></figure></p>
<p>3.查询访问最频繁的URL<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk &apos;&#123;print $7&#125;&apos; /var/log/nginx/access.log|sort | uniq -c |sort -n -k 1 -r|more</span><br></pre></td></tr></table></figure></p>
<p>4.查询访问最频繁的IP<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk &apos;&#123;print $1&#125;&apos; /var/log/nginx/access.log|sort | uniq -c |sort -n -k 1 -r|more</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/19/java_spring/study-spring-concurrent/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Victor">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Victor的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/19/java_spring/study-spring-concurrent/" itemprop="url">study-spring-concurrent</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-19T23:35:45+08:00">
                2018-03-19
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/03/19/java_spring/study-spring-concurrent/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/03/19/java_spring/study-spring-concurrent/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2018/03/19/java_spring/study-spring-concurrent/" class="leancloud_visitors" data-flag-title="study-spring-concurrent">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Spring并发访问的线程安全性问题"><a href="#Spring并发访问的线程安全性问题" class="headerlink" title="Spring并发访问的线程安全性问题"></a>Spring并发访问的线程安全性问题</h1><ul>
<li>只有无状态的Bean才可以在多线程环境下共享，在Spring中，绝大部分Bean都可以声明为singleton作用域。<br>那么对于有状态的bean呢？<br>Spring对一些（如RequestContextHolder、TransactionSynchronizationManager、LocaleContextHolder等）中非线程安全状态的bean采用ThreadLocal进行处理，让它们也成为线程安全的状态，因此有状态的Bean就可以在多线程中共享了。</li>
<li>如果用有状态的bean，也可以使用用prototype模式，每次在注入的时候就重新创建一个bean，在多线程中互不影响。</li>
</ul>
<h2 id="RequestContextHolder"><a href="#RequestContextHolder" class="headerlink" title="RequestContextHolder"></a>RequestContextHolder</h2><p>我们可以知道HttpServletRequest是在执行doService方法之前，也就是具体的业务逻辑前进行设置的，然后在执行完业务逻辑或者抛出异常时重置RequestContextHolder移除当前的HttpServletRequest。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/19/egenie_bugfix/bugfix-duplicate-key/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Victor">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Victor的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/19/egenie_bugfix/bugfix-duplicate-key/" itemprop="url">bugfix-duplicate-key</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-19T12:26:01+08:00">
                2018-03-19
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/03/19/egenie_bugfix/bugfix-duplicate-key/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/03/19/egenie_bugfix/bugfix-duplicate-key/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2018/03/19/egenie_bugfix/bugfix-duplicate-key/" class="leancloud_visitors" data-flag-title="bugfix-duplicate-key">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>一次bugfix的经历过</p>
<h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><h2 id="异常信息"><a href="#异常信息" class="headerlink" title="异常信息"></a>异常信息</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">java.lang.IllegalStateException: Duplicate key </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> at java.util.stream.Collectors.lambda$throwingMerger$0(Collectors.java:133) ~[?:1.8.0_92]</span><br><span class="line">        at java.util.HashMap.merge(HashMap.java:1253) ~[?:1.8.0_92]</span><br><span class="line">        at java.util.stream.Collectors.lambda$toMap$58(Collectors.java:1320) ~[?:1.8.0_92]</span><br><span class="line">        at java.util.stream.ReduceOps$3ReducingSink.accept(ReduceOps.java:169) ~[?:1.8.0_92]</span><br><span class="line">        at java.util.ArrayList$ArrayListSpliterator.forEachRemaining(ArrayList.java:1374) ~[?:1.8.0_92]</span><br><span class="line">        at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:481) ~[?:1.8.0_92]</span><br><span class="line">        at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:471) ~[?:1.8.0_92]</span><br><span class="line">        at java.util.stream.ReduceOps$ReduceOp.evaluateSequential(ReduceOps.java:708) ~[?:1.8.0_92]</span><br><span class="line">        at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234) ~[?:1.8.0_92]</span><br><span class="line">        at java.util.stream.ReferencePipeline.collect(ReferencePipeline.java:499) ~[?:1.8.0_92]</span><br><span class="line">        at</span><br></pre></td></tr></table></figure>
<h2 id="报错代码"><a href="#报错代码" class="headerlink" title="报错代码"></a>报错代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Long, PmsDailyPurchase&gt; result = all.stream().collect(Collectors.toMap(PmsDailyPurchase::getSaleOrderId, Function.identity()));</span><br></pre></td></tr></table></figure>
<p>对于ToMap方法没有做兼容,优点是方便问题的排查<br>逻辑上讲应该是不会出现Duplicate key 的</p>
<h2 id="主要逻辑"><a href="#主要逻辑" class="headerlink" title="主要逻辑"></a>主要逻辑</h2><p>先查询,如果不存在就插入</p>
<h2 id="问题总结"><a href="#问题总结" class="headerlink" title="问题总结"></a>问题总结</h2><ul>
<li>dubbo默认容错机制:dubbo默认的2次重复调用(加起来3次)</li>
<li>provider提供的接口没有幂等性</li>
<li>注解配置问题:项目中AvoidRepeatInvoke注解会对重复的调用进行处理<ul>
<li>未调用过:真正执行,保存调用结果</li>
<li>调用过:直接返回调用结果</li>
<li>调用的凭证是60s超时的,对于响应大于60s的会自动过期,但实际上还在执行,<strong>导致问题的发生</strong></li>
</ul>
</li>
<li>大事务:最近上线读写分离,在整个大方的外部添加了事务注解,导致无法自动提交,当并发时,可能查不到其他事务,已经insert但是没有提交的内容(此处也有幻读的风险,但是使用阿里rds测试后,没有发生)</li>
</ul>
<h1 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h1><ul>
<li>修改项目级别的默认容错机制, retries=0</li>
<li>超时时间设定<ul>
<li>统计监控微服务的方法级别超时时间,修改方法级别</li>
</ul>
</li>
<li>批量接口,限制最大数量,否则调用时间会太长</li>
<li>事务的范围,需要仔细考虑,不能有过大的事务</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/13/egenie_bugfix/bugfix-class-cast-exception/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Victor">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Victor的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/13/egenie_bugfix/bugfix-class-cast-exception/" itemprop="url">bugfix类转换异常</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-13T15:47:48+08:00">
                2018-03-13
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/03/13/egenie_bugfix/bugfix-class-cast-exception/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/03/13/egenie_bugfix/bugfix-class-cast-exception/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2018/03/13/egenie_bugfix/bugfix-class-cast-exception/" class="leancloud_visitors" data-flag-title="bugfix类转换异常">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="异常信息"><a href="#异常信息" class="headerlink" title="异常信息"></a>异常信息</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line">2018-03-13 15:36:51.409 [DubboServerHandler-10.47.124.90:20888-thread-100] ERROR com.alibaba.dubbo.rpc.filter.ExceptionFilter.error -  [DUBBO] Got unchecked and undeclared exception which called by 10.47.124.90. service: com.ejlerp.pms.api.OutOfStockOrderService, method: generateOOSPurchaseOrder, exception: java.lang.ClassCastException: com.alibaba.fastjson.JSONObject cannot be cast to com.ejlerp.pms.domain.PmsPurchaseOrderDetail, dubbo version: 2.8.4, current host: 10.47.124.90</span><br><span class="line">java.lang.ClassCastException: com.alibaba.fastjson.JSONObject cannot be cast to com.ejlerp.pms.domain.PmsPurchaseOrderDetail</span><br><span class="line">        at com.ejlerp.pms.provider.service.DailyPurchaseServiceImpl.writeBackDetailInfoToDailyDetails(DailyPurchaseServiceImpl.java:502)</span><br><span class="line">        at com.ejlerp.pms.provider.service.DailyPurchaseServiceImpl.generatePurchaseOrderAndDetails(DailyPurchaseServiceImpl.java:121)</span><br><span class="line">        at com.ejlerp.pms.provider.service.DailyPurchaseServiceImpl$$FastClassBySpringCGLIB$$3b1a314.invoke(&lt;generated&gt;)</span><br><span class="line">        at org.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:204)</span><br><span class="line">:</span><br><span class="line">eateNum=null,planCreateDate=null,version=null,cumulativeDefectNum=0,creator=null,createdAt=null,lastUpdater=null,lastUpdated=null,tenantId=null,isUsable=null]]</span><br><span class="line">2018-03-13 15:36:51.395 [DubboServerHandler-10.47.124.90:20888-thread-100] DEBUG com.ejlerp.dal.framework.service.advice.AvoidRepeatInvokeAdvice.aroundAdvice - 新建并发锁[msi_lock_pms-1035108456]</span><br><span class="line">2018-03-13 15:36:51.399 [DubboServerHandler-10.47.124.90:20888-thread-100] WARN  com.ejlerp.dal.framework.service.advice.AvoidRepeatInvokeAdvice.aroundAdvice - 存在重复锁[msi_fp_pms-1035108456]</span><br><span class="line">2018-03-13 15:36:51.401 [DubboServerHandler-10.47.124.90:20888-thread-100] DEBUG com.ejlerp.dal.framework.service.advice.AvoidRepeatInvokeAdvice.aroundAdvice - 释放并发锁[msi_lock_pms-1035108456]</span><br><span class="line">2018-03-13 15:36:51.404 [DubboServerHandler-10.47.124.90:20888-thread-100] DEBUG com.ejlerp.dal.framework.service.advice.AvoidRepeatInvokeAdvice.aroundAdvice - 释放并发锁[msi_lock_pms1289336139]</span><br><span class="line">2018-03-13 15:36:51.409 [DubboServerHandler-10.47.124.90:20888-thread-100] ERROR com.alibaba.dubbo.rpc.filter.ExceptionFilter.error -  [DUBBO] Got unchecked and undeclared exception which called by 10.47.124.90. service: com.ejlerp.pms.api.OutOfStockOrderService, method: generateOOSPurchaseOrder, exception: java.lang.ClassCastException: com.alibaba.fastjson.JSONObject cannot be cast to com.ejlerp.pms.domain.PmsPurchaseOrderDetail, dubbo version: 2.8.4, current host: 10.47.124.90</span><br><span class="line">java.lang.ClassCastException: com.alibaba.fastjson.JSONObject cannot be cast to com.ejlerp.pms.domain.PmsPurchaseOrderDetail</span><br><span class="line">        at com.ejlerp.pms.provider.service.DailyPurchaseServiceImpl.writeBackDetailInfoToDailyDetails(DailyPurchaseServiceImpl.java:502)</span><br><span class="line">        at com.ejlerp.pms.provider.service.DailyPurchaseServiceImpl.generatePurchaseOrderAndDetails(DailyPurchaseServiceImpl.java:121)</span><br><span class="line">        at com.ejlerp.pms.provider.service.DailyPurchaseServiceImpl$$FastClassBySpringCGLIB$$3b1a314.invoke(&lt;generated&gt;)</span><br><span class="line">        at org.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:204)</span><br><span class="line">        at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.invokeJoinpoint(CglibAopProxy.java:738)</span><br><span class="line">        at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:157)</span><br><span class="line">        at org.springframework.transaction.interceptor.TransactionInterceptor$1.proceedWithInvocation(TransactionInterceptor.java:99)</span><br><span class="line">        at org.springframework.transaction.interceptor.TransactionAspectSupport.invokeWithinTransaction(TransactionAspectSupport.java:282)</span><br><span class="line">        at org.springframework.transaction.interceptor.TransactionInterceptor.invoke(TransactionInterceptor.java:96)</span><br><span class="line">        at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:179)</span><br><span class="line">        at org.springframework.aop.framework.adapter.MethodBeforeAdviceInterceptor.invoke(MethodBeforeAdviceInterceptor.java:52)</span><br><span class="line">        at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:168)</span><br><span class="line">        at org.springframework.aop.aspectj.MethodInvocationProceedingJoinPoint.proceed(MethodInvocationProceedingJoinPoint.java:97)</span><br><span class="line">        at com.ejlerp.dal.framework.service.advice.AvoidRepeatInvokeAdvice.aroundAdvice(AvoidRepeatInvokeAdvice.java:131)</span><br><span class="line">        at sun.reflect.GeneratedMethodAccessor270.invoke(Unknown Source)</span><br><span class="line">        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</span><br><span class="line">        at java.lang.reflect.Method.invoke(Method.java:498)</span><br><span class="line">        at org.springframework.aop.aspectj.AbstractAspectJAdvice.invokeAdviceMethodWithGivenArgs(AbstractAspectJAdvice.java:629)</span><br><span class="line">        at org.springframework.aop.aspectj.AbstractAspectJAdvice.invokeAdviceMethod(AbstractAspectJAdvice.java:618)</span><br><span class="line">        at org.springframework.aop.aspectj.AspectJAroundAdvice.invoke(AspectJAroundAdvice.java:70)</span><br><span class="line">:</span><br><span class="line">eateNum=null,planCreateDate=null,version=null,cumulativeDefectNum=0,creator=null,createdAt=null,lastUpdater=null,lastUpdated=null,tenantId=null,isUsable=null]]</span><br><span class="line">2018-03-13 15:36:51.395 [DubboServerHandler-10.47.124.90:20888-thread-100] DEBUG com.ejlerp.dal.framework.service.advice.AvoidRepeatInvokeAdvice.aroundAdvice - 新建并发锁[msi_lock_pms-1035108456]</span><br><span class="line">2018-03-13 15:36:51.399 [DubboServerHandler-10.47.124.90:20888-thread-100] WARN  com.ejlerp.dal.framework.service.advice.AvoidRepeatInvokeAdvice.aroundAdvice - 存在重复锁[msi_fp_pms-1035108456]</span><br><span class="line">2018-03-13 15:36:51.401 [DubboServerHandler-10.47.124.90:20888-thread-100] DEBUG com.ejlerp.dal.framework.service.advice.AvoidRepeatInvokeAdvice.aroundAdvice - 释放并发锁[msi_lock_pms-1035108456]</span><br><span class="line">2018-03-13 15:36:51.404 [DubboServerHandler-10.47.124.90:20888-thread-100] DEBUG com.ejlerp.dal.framework.service.advice.AvoidRepeatInvokeAdvice.aroundAdvice - 释放并发锁[msi_lock_pms1289336139]</span><br><span class="line">2018-03-13 15:36:51.409 [DubboServerHandler-10.47.124.90:20888-thread-100] ERROR com.alibaba.dubbo.rpc.filter.ExceptionFilter.error -  [DUBBO] Got unchecked and undeclared exception which called by 10.47.124.90. service: com.ejlerp.pms.api.OutOfStockOrderService, method: generateOOSPurchaseOrder, exception: java.lang.ClassCastException: com.alibaba.fastjson.JSONObject cannot be cast to com.ejlerp.pms.domain.PmsPurchaseOrderDetail, dubbo version: 2.8.4, current host: 10.47.124.90</span><br><span class="line">java.lang.ClassCastException: com.alibaba.fastjson.JSONObject cannot be cast to com.ejlerp.pms.domain.PmsPurchaseOrderDetail</span><br><span class="line">        at com.ejlerp.pms.provider.service.DailyPurchaseServiceImpl.writeBackDetailInfoToDailyDetails(DailyPurchaseServiceImpl.java:502)</span><br><span class="line">        at com.ejlerp.pms.provider.service.DailyPurchaseServiceImpl.generatePurchaseOrderAndDetails(DailyPurchaseServiceImpl.java:121)</span><br><span class="line">        at com.ejlerp.pms.provider.service.DailyPurchaseServiceImpl$$FastClassBySpringCGLIB$$3b1a314.invoke(&lt;generated&gt;)</span><br><span class="line">        at org.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:204)</span><br><span class="line">        at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.invokeJoinpoint(CglibAopProxy.java:738)</span><br><span class="line">        at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:157)</span><br><span class="line">        at org.springframework.transaction.interceptor.TransactionInterceptor$1.proceedWithInvocation(TransactionInterceptor.java:99)</span><br><span class="line">        at org.springframework.transaction.interceptor.TransactionAspectSupport.invokeWithinTransaction(TransactionAspectSupport.java:282)</span><br><span class="line">        at org.springframework.transaction.interceptor.TransactionInterceptor.invoke(TransactionInterceptor.java:96)</span><br><span class="line">        at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:179)</span><br><span class="line">        at org.springframework.aop.framework.adapter.MethodBeforeAdviceInterceptor.invoke(MethodBeforeAdviceInterceptor.java:52)</span><br><span class="line">        at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:168)</span><br><span class="line">        at org.springframework.aop.aspectj.MethodInvocationProceedingJoinPoint.proceed(MethodInvocationProceedingJoinPoint.java:97)</span><br><span class="line">        at com.ejlerp.dal.framework.service.advice.AvoidRepeatInvokeAdvice.aroundAdvice(AvoidRepeatInvokeAdvice.java:131)</span><br><span class="line">        at sun.reflect.GeneratedMethodAccessor270.invoke(Unknown Source)</span><br><span class="line">        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</span><br><span class="line">        at java.lang.reflect.Method.invoke(Method.java:498)</span><br><span class="line">        at org.springframework.aop.aspectj.AbstractAspectJAdvice.invokeAdviceMethodWithGivenArgs(AbstractAspectJAdvice.java:629)</span><br><span class="line">        at org.springframework.aop.aspectj.AbstractAspectJAdvice.invokeAdviceMethod(AbstractAspectJAdvice.java:618)</span><br><span class="line">        at org.springframework.aop.aspectj.AspectJAroundAdvice.invoke(AspectJAroundAdvice.java:70)</span><br><span class="line">        at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:168)</span><br><span class="line">        at org.springframework.aop.aspectj.AspectJAfterAdvice.invoke(AspectJAfterAdvice.java:47)</span><br><span class="line">        at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:168)</span><br><span class="line">        at org.springframework.aop.interceptor.ExposeInvocationInterceptor.invoke(ExposeInvocationInterceptor.java:92)</span><br><span class="line">        at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:179)</span><br><span class="line">        at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:673)</span><br><span class="line">        at com.ejlerp.pms.provider.service.DailyPurchaseServiceImpl$$EnhancerBySpringCGLIB$$41b3ba70.generatePurchaseOrderAndDetails(&lt;generated&gt;)</span><br><span class="line">        at sun.reflect.GeneratedMethodAccessor283.invoke(Unknown Source)</span><br><span class="line">        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</span><br><span class="line">        at java.lang.reflect.Method.invoke(Method.java:498)</span><br><span class="line">        at org.springframework.aop.support.AopUtils.invokeJoinpointUsingReflection(AopUtils.java:333)</span><br><span class="line">        at org.springframework.aop.framework.JdkDynamicAopProxy.invoke(JdkDynamicAopProxy.java:207)</span><br><span class="line">        at com.sun.proxy.$Proxy77.generatePurchaseOrderAndDetails(Unknown Source)</span><br><span class="line">        at com.ejlerp.pms.provider.service.oms.OutOfStockOrderServiceImpl$ToPurchaseOrder.invoke(OutOfStockOrderServiceImpl.java:931)</span><br><span class="line">        at com.ejlerp.pms.provider.service.oms.OutOfStockOrderServiceImpl.getToPurchaseOrderResult(OutOfStockOrderServiceImpl.java:250)</span><br><span class="line">        at com.ejlerp.pms.provider.service.oms.OutOfStockOrderServiceImpl.generateOOSPurchaseOrder(OutOfStockOrderServiceImpl.java:215)</span><br><span class="line">        at com.ejlerp.pms.provider.service.oms.OutOfStockOrderServiceImpl.generateOOSPurchaseOrder(OutOfStockOrderServiceImpl.java:125)</span><br><span class="line">        at com.ejlerp.pms.provider.service.oms.OutOfStockOrderServiceImpl$$FastClassBySpringCGLIB$$5a5ccc6a.invoke(&lt;generated&gt;)</span><br><span class="line">        at org.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:204)</span><br><span class="line">        at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.invokeJoinpoint(CglibAopProxy.java:738)</span><br><span class="line">        at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:157)</span><br><span class="line">        at org.springframework.transaction.interceptor.TransactionInterceptor$1.proceedWithInvocation(TransactionInterceptor.java:99)</span><br><span class="line">        at org.springframework.transaction.interceptor.TransactionAspectSupport.invokeWithinTransaction(TransactionAspectSupport.java:282)</span><br><span class="line">        at org.springframework.transaction.interceptor.TransactionInterceptor.invoke(TransactionInterceptor.java:96)</span><br><span class="line">        at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:179)</span><br><span class="line">        at org.springframework.aop.interceptor.ExposeInvocationInterceptor.invoke(ExposeInvocationInterceptor.java:92)</span><br><span class="line">        at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:179)</span><br><span class="line">        at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:673)</span><br><span class="line">        at com.ejlerp.pms.provider.service.oms.OutOfStockOrderServiceImpl$$EnhancerBySpringCGLIB$$c7b6bc32.generateOOSPurchaseOrder(&lt;generated&gt;)</span><br><span class="line">        at com.alibaba.dubbo.common.bytecode.Wrapper56.invokeMethod(Wrapper56.java)</span><br><span class="line">        at com.alibaba.dubbo.rpc.proxy.javassist.JavassistProxyFactory$1.doInvoke(JavassistProxyFactory.java:46)</span><br><span class="line">        at com.alibaba.dubbo.rpc.proxy.AbstractProxyInvoker.invoke(AbstractProxyInvoker.java:72)</span><br><span class="line">        at com.alibaba.dubbo.rpc.protocol.InvokerWrapper.invoke(InvokerWrapper.java:53)</span><br><span class="line">        at com.alibaba.dubbo.rpc.filter.ExceptionFilter.invoke(ExceptionFilter.java:64)</span><br><span class="line">        at com.alibaba.dubbo.rpc.protocol.ProtocolFilterWrapper$1.invoke(ProtocolFilterWrapper.java:91)</span><br><span class="line">        at com.alibaba.dubbo.monitor.support.MonitorFilter.invoke(MonitorFilter.java:75)</span><br><span class="line">        at com.alibaba.dubbo.rpc.protocol.ProtocolFilterWrapper$1.invoke(ProtocolFilterWrapper.java:91)</span><br><span class="line">        at com.alibaba.dubbo.rpc.filter.TimeoutFilter.invoke(TimeoutFilter.java:42)</span><br><span class="line">        at com.alibaba.dubbo.rpc.protocol.ProtocolFilterWrapper$1.invoke(ProtocolFilterWrapper.java:91)</span><br><span class="line">        at com.alibaba.dubbo.rpc.protocol.dubbo.filter.TraceFilter.invoke(TraceFilter.java:78)</span><br><span class="line">        at com.alibaba.dubbo.rpc.protocol.ProtocolFilterWrapper$1.invoke(ProtocolFilterWrapper.java:91)</span><br><span class="line">        at com.alibaba.dubbo.rpc.filter.ContextFilter.invoke(ContextFilter.java:70)</span><br><span class="line">        at com.alibaba.dubbo.rpc.protocol.ProtocolFilterWrapper$1.invoke(ProtocolFilterWrapper.java:91)</span><br><span class="line">        at com.alibaba.dubbo.rpc.filter.GenericFilter.invoke(GenericFilter.java:132)</span><br><span class="line">        at com.alibaba.dubbo.rpc.protocol.ProtocolFilterWrapper$1.invoke(ProtocolFilterWrapper.java:91)</span><br><span class="line">        at com.alibaba.dubbo.rpc.filter.ClassLoaderFilter.invoke(ClassLoaderFilter.java:38)</span><br><span class="line">        at com.alibaba.dubbo.rpc.protocol.ProtocolFilterWrapper$1.invoke(ProtocolFilterWrapper.java:91)</span><br><span class="line">        at com.alibaba.dubbo.rpc.filter.EchoFilter.invoke(EchoFilter.java:38)</span><br><span class="line">        at com.alibaba.dubbo.rpc.protocol.ProtocolFilterWrapper$1.invoke(ProtocolFilterWrapper.java:91)</span><br><span class="line">        at com.alibaba.dubbo.rpc.protocol.dubbo.DubboProtocol$1.reply(DubboProtocol.java:113)</span><br><span class="line">        at com.alibaba.dubbo.remoting.exchange.support.header.HeaderExchangeHandler.handleRequest(HeaderExchangeHandler.java:84)</span><br><span class="line">        at com.alibaba.dubbo.remoting.exchange.support.header.HeaderExchangeHandler.received(HeaderExchangeHandler.java:170)</span><br><span class="line">        at com.alibaba.dubbo.remoting.transport.DecodeHandler.received(DecodeHandler.java:52)</span><br><span class="line">        at com.alibaba.dubbo.remoting.transport.dispatcher.ChannelEventRunnable.run(ChannelEventRunnable.java:82)</span><br><span class="line">        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)</span><br><span class="line">        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:745)</span><br></pre></td></tr></table></figure>
<h1 id="排查步骤"><a href="#排查步骤" class="headerlink" title="排查步骤"></a>排查步骤</h1><ul>
<li>1.排查最近的代码改动,没有相关的修改</li>
<li>2.在代码中加入debug信息,逐行查找变化</li>
<li><p>3.排查发现可能是aop的代码导致</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@AvoidRepeatInvoke(prefix = &quot;pms&quot;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>4.原先的逻辑</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (kvCacher.exist(footprint)) &#123;</span><br><span class="line">    //判断redis是否存在调用过的足迹,如有,直接返回上一次的结果</span><br><span class="line">    LOGGER.warn(&quot;存在重复锁[&#123;&#125;]&quot;, footprint);</span><br><span class="line">    return JSON.parseObject(kvCacher.get(fpVal), retClass);</span><br></pre></td></tr></table></figure>
</li>
<li><p>5.fastjson中对于带泛型的反持久化应该用type的方式<br><a href="https://github.com/alibaba/fastjson/wiki/TypeReference" target="_blank" rel="noopener">https://github.com/alibaba/fastjson/wiki/TypeReference</a></p>
</li>
<li><p>6.试验</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">public class Reflect &#123;</span><br><span class="line"></span><br><span class="line">    public List&lt;A&gt; hello() &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws NoSuchMethodException, NoSuchFieldException, IllegalAccessException &#123;</span><br><span class="line">        Class&lt;Reflect&gt; reflectClass = Reflect.class;</span><br><span class="line">        Method hello = reflectClass.getMethod(&quot;hello&quot;, null);</span><br><span class="line">        Type genericReturnType = hello.getGenericReturnType();</span><br><span class="line">        System.out.println(genericReturnType);</span><br><span class="line">        ArrayList&lt;A&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">        list.add(new A(&quot;AA1&quot;));</span><br><span class="line">        list.add(new A(&quot;AA2&quot;));</span><br><span class="line">        list.add(new A(&quot;AA3&quot;));</span><br><span class="line">        list.add(new A(&quot;AA4&quot;));</span><br><span class="line">        String json = JSON.toJSONString(list);</span><br><span class="line">        //传统方式</span><br><span class="line">//        List&lt;A&gt; as = JSON.parseObject(json, new TypeReference&lt;List&lt;A&gt;&gt;() &#123;&#125;.getType());</span><br><span class="line">		//反射方式</span><br><span class="line">        List&lt;A&gt; as = JSON.parseObject(json, new TypeReference4Reflect(genericReturnType).getType());</span><br><span class="line"></span><br><span class="line">        System.out.println(as);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static class A implements Serializable &#123;</span><br><span class="line">        String name;</span><br><span class="line"></span><br><span class="line">        public A(String name) &#123;</span><br><span class="line">            this.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public String getName() &#123;</span><br><span class="line">            return name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void setName(String name) &#123;</span><br><span class="line">            this.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public String toString() &#123;</span><br><span class="line">            final StringBuffer sb = new StringBuffer(&quot;A&#123;&quot;);</span><br><span class="line">            sb.append(&quot;name=&apos;&quot;).append(name).append(&apos;\&apos;&apos;);</span><br><span class="line">            sb.append(&apos;&#125;&apos;);</span><br><span class="line">            return sb.toString();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static public class TypeReference4Reflect&lt;T&gt; extends TypeReference&lt;T&gt; &#123;</span><br><span class="line">        public TypeReference4Reflect(T t) throws IllegalArgumentException, IllegalAccessException, SecurityException, NoSuchFieldException &#123;</span><br><span class="line">            Class&lt;?&gt; cla = TypeReference.class;</span><br><span class="line">            Field field = cla.getDeclaredField(&quot;type&quot;);</span><br><span class="line">            field.setAccessible(true);</span><br><span class="line">            field.set(this, t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>7.改造</li>
</ul>
<p>参考:<a href="http://www.iteye.com/problems/80586" target="_blank" rel="noopener">http://www.iteye.com/problems/80586</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">            return JSON.parseObject(cacheResult, new TypeReference4Reflect(genericReturnType).getType());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static public class TypeReference4Reflect&lt;T&gt; extends TypeReference&lt;T&gt; &#123;</span><br><span class="line">    public TypeReference4Reflect(T t) throws IllegalArgumentException, IllegalAccessException, SecurityException, NoSuchFieldException &#123;</span><br><span class="line">        Class&lt;?&gt; cla = TypeReference.class;</span><br><span class="line">        Field field = cla.getDeclaredField(&quot;type&quot;);</span><br><span class="line">        field.setAccessible(true);</span><br><span class="line">        field.set(this, t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h1><ul>
<li>日志中可能会有细节,要注意观察</li>
<li>排查步骤,要全面,逐步深入,debug信息表示调用行数</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/10/egenie_bugfix/bugfix-mysql-lock-timeout/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Victor">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Victor的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/10/egenie_bugfix/bugfix-mysql-lock-timeout/" itemprop="url">mysql锁超时处理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-10T12:12:00+08:00">
                2018-03-10
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/03/10/egenie_bugfix/bugfix-mysql-lock-timeout/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/03/10/egenie_bugfix/bugfix-mysql-lock-timeout/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2018/03/10/egenie_bugfix/bugfix-mysql-lock-timeout/" class="leancloud_visitors" data-flag-title="mysql锁超时处理">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>生成采购单逻辑,一直报错,锁等待超时<br>手动删除这个记录也是报错,应该是锁了pms_daily_group的id为101958的记录</p>
<h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select l.* from ( select &apos;Blocker&apos; role, p.id, p.user, left(p.host, locate(&apos;:&apos;, p.host) - 1) host, tx.trx_id, tx.trx_state, tx.trx_started, timestampdiff(second, tx.trx_started, now()) duration, lo.lock_mode, lo.lock_type, lo.lock_table, lo.lock_index, tx.trx_query, lw.requesting_thd_id Blockee_id, lw.requesting_trx_id Blockee_trx from information_schema.innodb_trx tx, information_schema.innodb_lock_waits lw, information_schema.innodb_locks lo, information_schema.processlist p where lw.blocking_trx_id = tx.trx_id and p.id = tx.trx_mysql_thread_id and lo.lock_id = lw.blocking_lock_id union select &apos;Blockee&apos; role, p.id, p.user, left(p.host, locate(&apos;:&apos;, p.host) - 1) host, tx.trx_id, tx.trx_state, tx.trx_started, timestampdiff(second, tx.trx_started, now()) duration, lo.lock_mode, lo.lock_type, lo.lock_table, lo.lock_index, tx.trx_query, null, null from information_schema.innodb_trx tx, information_schema.innodb_lock_waits lw, information_schema.innodb_locks lo, information_schema.processlist p where lw.requesting_trx_id = tx.trx_id and p.id = tx.trx_mysql_thread_id and lo.lock_id = lw.requested_lock_id) l order by role desc, trx_state desc;</span><br><span class="line"></span><br><span class="line">kill 184631781</span><br></pre></td></tr></table></figure>
<p>发现了未提交的事务</p>
<table border="1" style="border-collapse:collapse"><br><tr><th>role</th><th>id</th><th>user</th><th>host</th><th>trx_id</th><th>trx_state</th><th>trx_started</th><th>duration</th><th>lock_mode</th><th>lock_type</th><th>lock_table</th><th>lock_index</th><th>trx_query</th><th>Blockee_id</th><th>Blockee_trx</th></tr><br><tr><td>Blocker</td><td>184631781</td><td>egeniekn</td><td>10.26.109.140</td><td>4994407160</td><td>RUNNING</td><td>2018-03-10 10:39:22</td><td>4996</td><td>X</td><td>RECORD</td><td><code>egenie_kn</code>.<code>pms_daily_group</code></td><td>PRIMARY</td><td>NULL</td><td>184600424</td><td>4996523486</td></tr><br><tr><td>Blockee</td><td>184600424</td><td>egeniekn</td><td>10.25.241.203</td><td>4996523486</td><td>LOCK WAIT</td><td>2018-03-10 12:02:32</td><td>6</td><td>X</td><td>RECORD</td><td><code>egenie_kn</code>.<code>pms_daily_group</code></td><td>PRIMARY</td><td>/<em> ApplicationName=DataGrip 2017.3 </em>/ UPDATE <code>egenie_kn</code>.<code>pms_daily_group</code> t SET t.<code>is_usable</code> = 0 WHERE t.<code>pms_daily_group_id</code> = 101958</td><td>NULL</td><td>NULL</td></tr></table>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/05/java_data_structure/study-binary-heap/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Victor">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Victor的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/05/java_data_structure/study-binary-heap/" itemprop="url">study-binary-heap</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-05T10:20:49+08:00">
                2018-03-05
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/03/05/java_data_structure/study-binary-heap/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/03/05/java_data_structure/study-binary-heap/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2018/03/05/java_data_structure/study-binary-heap/" class="leancloud_visitors" data-flag-title="study-binary-heap">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="什么是二叉堆"><a href="#什么是二叉堆" class="headerlink" title="什么是二叉堆"></a>什么是二叉堆</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p> 二叉堆故名思议是一种特殊的堆，二叉堆具有堆的性质（父节点的键值总是大于或等于（小于或等于）任何一个子节点的键值），二叉堆又具有二叉树的性质（二叉堆是完全二叉树或者是近似完全二叉树）。当父节点的键值大于或等于（小于或等于）它的每一个子节点的键值时我们称它为最大堆（最小堆）。<br>      二叉堆多数是以数组作为它们底层元素的存储，根节点在数组中的索引是1，存储在第n个位置的父节点它的子节点在数组中的存储位置为2n与2n+1。可以借用网上的一幅图来标示这种存储结构。其中数字表明节点在数组中的存储位置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">       1               </span><br><span class="line">     /   \           </span><br><span class="line">    2     3             </span><br><span class="line">   / \   / \       </span><br><span class="line">  4   5  6  7     </span><br><span class="line"> / \ / \        </span><br><span class="line">8  9 10 11</span><br></pre></td></tr></table></figure>
<h2 id="二叉堆支持的操作"><a href="#二叉堆支持的操作" class="headerlink" title="二叉堆支持的操作"></a>二叉堆支持的操作</h2><p>二叉堆通常支持以下操作：删除，插入节点,创建二叉堆。这些操作复杂对都是O(log2n)</p>
<p>二叉堆也可以支持这些操作：查找。O(n)复杂度。</p>
<h2 id="二叉堆的特点"><a href="#二叉堆的特点" class="headerlink" title="二叉堆的特点"></a>二叉堆的特点</h2><p>二叉堆是专门为取出最大或最小节点而设计点数据结构，这种数据结构在查找一般元素方面性能和一般数组是没有多大区别的。二叉堆在取出最大或最最小值的性能表现是O(1)，取出操作完成之后，二叉堆需要一次整形操作，以便得到下一个最值，这个操作复杂度O(log2n)。这是一个相当理想的操作时间。但是二叉堆也有一个缺点，就是二叉堆对存储在内存中的数据操作太过分散，这导致了二叉堆在cpu高速缓存的利用与内存击中率上面表现不是很好，这也是一个二叉堆理想操作时间所需要付出的代价。</p>
<h1 id="二叉堆的实现"><a href="#二叉堆的实现" class="headerlink" title="二叉堆的实现"></a>二叉堆的实现</h1><h1 id="二叉堆的应用"><a href="#二叉堆的应用" class="headerlink" title="二叉堆的应用"></a>二叉堆的应用</h1>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/04/blockchain/draft-blockchain/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Victor">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Victor的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/04/blockchain/draft-blockchain/" itemprop="url">draft-blockchain</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-04T15:13:55+08:00">
                2018-03-04
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/03/04/blockchain/draft-blockchain/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/03/04/blockchain/draft-blockchain/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2018/03/04/blockchain/draft-blockchain/" class="leancloud_visitors" data-flag-title="draft-blockchain">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="区块链的本质"><a href="#区块链的本质" class="headerlink" title="区块链的本质"></a>区块链的本质</h1><p>分布式数据库</p>
<p>首先，区块链的主要作用是储存信息。任何需要保存的信息，都可以写入区块链，也可以从里面读取，所以它是数据库。</p>
<p>其次，任何人都可以架设服务器，加入区块链网络，成为一个节点。区块链的世界里面，没有中心节点，每个节点都是平等的，都保存着整个数据库。你可以向任何一个节点，写入/读取数据，因为所有节点最后都会同步，保证区块链一致。</p>
<h1 id="区块链的最大特点"><a href="#区块链的最大特点" class="headerlink" title="区块链的最大特点"></a>区块链的最大特点</h1><p>分布式数据库并非新发明，市场上早有此类产品。但是，区块链有一个革命性特点。</p>
<p>区块链没有管理员，它是彻底无中心的。其他的数据库都有管理员，但是区块链没有。如果有人想对区块链添加审核，也实现不了，因为它的设计目标就是防止出现居于中心地位的管理当局。</p>
<p>正是因为无法管理，区块链才能做到无法被控制。否则一旦大公司大集团控制了管理权，他们就会控制整个平台，其他使用者就都必须听命于他们了。</p>
<p>但是，没有了管理员，人人都可以往里面写入数据，怎么才能保证数据是可信的呢？被坏人改了怎么办？请接着往下读，这就是区块链奇妙的地方。</p>
<h1 id="区块"><a href="#区块" class="headerlink" title="区块"></a>区块</h1><p>区块链由一个个区块（block）组成。区块很像数据库的记录，每次写入数据，就是创建一个区块。</p>
<p>每个区块包含两个部分。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">区块头（Head）：记录当前区块的特征值</span><br><span class="line">区块体（Body）：实际数据</span><br></pre></td></tr></table></figure>
<p>区块头包含了当前区块的多项特征值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">生成时间</span><br><span class="line">实际数据（即区块体）的哈希</span><br><span class="line">上一个区块的哈希</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>这里，你需要理解什么叫哈希（hash），这是理解区块链必需的。</p>
<p>所谓”哈希”就是计算机可以对任意内容，计算出一个长度相同的特征值。区块链的 哈希长度是256位，这就是说，不管原始内容是什么，最后都会计算出一个256位的二进制数字。而且可以保证，只要原始内容不同，对应的哈希一定是不同的。</p>
<p>举例来说，字符串123的哈希是a8fdc205a9f19cc1c7507a60c4f01b13d11d7fd0（十六进制），转成二进制就是256位，而且只有123能得到这个哈希。（理论上，其他字符串也有可能得到这个哈希，但是概率极低，可以近似认为不可能发生。）</p>
<p>因此，就有两个重要的推论。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">推论1：每个区块的哈希都是不一样的，可以通过哈希标识区块。</span><br><span class="line">推论2：如果区块的内容变了，它的哈希一定会改变。</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/02/28/java_thread/JUC-ReetrantLock/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Victor">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Victor的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/28/java_thread/JUC-ReetrantLock/" itemprop="url">ReetrantLock源码</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-28T19:12:09+08:00">
                2018-02-28
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/02/28/java_thread/JUC-ReetrantLock/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/02/28/java_thread/JUC-ReetrantLock/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2018/02/28/java_thread/JUC-ReetrantLock/" class="leancloud_visitors" data-flag-title="ReetrantLock源码">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Lock接口"><a href="#Lock接口" class="headerlink" title="Lock接口"></a>Lock接口</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Lock lock = new ReentrantLock();</span><br><span class="line">lock.lock();</span><br><span class="line">try&#123;</span><br><span class="line">    //临界区......</span><br><span class="line">&#125;finally&#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>正如代码所显示(ReentrantLock是Lock的实现类，稍后分析)，当前线程使用lock()方法与unlock()对临界区进行包围，其他线程由于无法持有锁将无法进入临界区直到当前线程释放锁，注意unlock()操作必须在finally代码块中，这样可以确保即使临界区执行抛出异常，线程最终也能正常释放锁，Lock接口还提供了锁以下相关方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">ublic interface Lock &#123;</span><br><span class="line">    //加锁</span><br><span class="line">    void lock();</span><br><span class="line"></span><br><span class="line">    //解锁</span><br><span class="line">    void unlock();</span><br><span class="line"></span><br><span class="line">    //可中断获取锁，与lock()不同之处在于可响应中断操作，即在获</span><br><span class="line">    //取锁的过程中可中断，注意synchronized在获取锁时是不可中断的</span><br><span class="line">    void lockInterruptibly() throws InterruptedException;</span><br><span class="line"></span><br><span class="line">    //尝试非阻塞获取锁，调用该方法后立即返回结果，如果能够获取则返回true，否则返回false</span><br><span class="line">    boolean tryLock();</span><br><span class="line"></span><br><span class="line">    //根据传入的时间段获取锁，在指定时间内没有获取锁则返回false，如果在指定时间内当前线程未被中并断获取到锁则返回true</span><br><span class="line">    boolean tryLock(long time, TimeUnit unit) throws InterruptedException;</span><br><span class="line"></span><br><span class="line">    //获取等待通知组件，该组件与当前锁绑定，当前线程只有获得了锁</span><br><span class="line">    //才能调用该组件的wait()方法，而调用后，当前线程将释放锁。</span><br><span class="line">    Condition newCondition();</span><br></pre></td></tr></table></figure>
<p>可见Lock对象锁还提供了synchronized所不具备的其他同步特性，如可中断锁的获取(synchronized在等待获取锁时是不可中的)，超时中断锁的获取，等待唤醒机制的多条件变量Condition等，这也使得Lock锁在使用上具有更大的灵活性。下面进一步分析Lock的实现类重入锁ReetrantLock。</p>
<h1 id="重入锁ReetrantLock"><a href="#重入锁ReetrantLock" class="headerlink" title="重入锁ReetrantLock"></a>重入锁ReetrantLock</h1><p>重入锁ReetrantLock，JDK 1.5新增的类，实现了Lock接口，作用与synchronized关键字相当，但比synchronized更加灵活。ReetrantLock本身也是一种支持重进入的锁，即该锁可以支持一个线程对资源重复加锁，同时也支持公平锁与非公平锁。所谓的公平与非公平指的是在请求先后顺序上，先对锁进行请求的就一定先获取到锁，那么这就是公平锁，反之，如果对于锁的获取并没有时间上的先后顺序，如后请求的线程可能先获取到锁，这就是非公平锁，一般而言非，非公平锁机制的效率往往会胜过公平锁的机制，但在某些场景下，可能更注重时间先后顺序，那么公平锁自然是很好的选择。需要注意的是ReetrantLock支持对同一线程重加锁，但是加锁多少次，就必须解锁多少次，这样才可以成功释放锁。下面看看ReetrantLock的简单使用案例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line">public class ReenterLock implements Runnable&#123;</span><br><span class="line">    public static ReentrantLock lock=new ReentrantLock();</span><br><span class="line">    public static int i=0;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        for(int j=0;j&lt;10000000;j++)&#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            //支持重入锁</span><br><span class="line">            lock.lock();</span><br><span class="line">            try&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;finally&#123;</span><br><span class="line">                //执行两次解锁</span><br><span class="line">                lock.unlock();</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        ReenterLock tl=new ReenterLock();</span><br><span class="line">        Thread t1=new Thread(tl);</span><br><span class="line">        Thread t2=new Thread(tl);</span><br><span class="line">        t1.start();t2.start();</span><br><span class="line">        t1.join();t2.join();</span><br><span class="line">        //输出结果：20000000</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码非常简单，我们使用两个线程同时操作临界资源i，执行自增操作，使用ReenterLock进行加锁，解决线程安全问题，这里进行了两次重复加锁，由于ReenterLock支持重入，因此这样是没有问题的，需要注意的是在finally代码块中，<b>需执行两次解锁操作才能真正成功地让当前执行线程释放锁</b>，从这里看ReenterLock的用法还是非常简单的，除了实现Lock接口的方法，ReenterLock其他方法说明如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">//查询当前线程保持此锁的次数。</span><br><span class="line">int getHoldCount()</span><br><span class="line"></span><br><span class="line">//返回目前拥有此锁的线程，如果此锁不被任何线程拥有，则返回 null。      </span><br><span class="line">protected  Thread   getOwner();</span><br><span class="line"></span><br><span class="line">//返回一个 collection，它包含可能正等待获取此锁的线程，其内部维持一个队列，这点稍后会分析。      </span><br><span class="line">protected  Collection&lt;Thread&gt;   getQueuedThreads();</span><br><span class="line"></span><br><span class="line">//返回正等待获取此锁的线程估计数。   </span><br><span class="line">int getQueueLength();</span><br><span class="line"></span><br><span class="line">// 返回一个 collection，它包含可能正在等待与此锁相关给定条件的那些线程。</span><br><span class="line">protected  Collection&lt;Thread&gt;   getWaitingThreads(Condition condition);</span><br><span class="line"></span><br><span class="line">//返回等待与此锁相关的给定条件的线程估计数。       </span><br><span class="line">int getWaitQueueLength(Condition condition);</span><br><span class="line"></span><br><span class="line">// 查询给定线程是否正在等待获取此锁。     </span><br><span class="line">boolean hasQueuedThread(Thread thread);</span><br><span class="line"></span><br><span class="line">//查询是否有些线程正在等待获取此锁。     </span><br><span class="line">boolean hasQueuedThreads();</span><br><span class="line"></span><br><span class="line">//查询是否有些线程正在等待与此锁有关的给定条件。     </span><br><span class="line">boolean hasWaiters(Condition condition);</span><br><span class="line"></span><br><span class="line">//如果此锁的公平设置为 true，则返回 true。     </span><br><span class="line">boolean isFair()</span><br><span class="line"></span><br><span class="line">//查询当前线程是否保持此锁。      </span><br><span class="line">boolean isHeldByCurrentThread()</span><br><span class="line"></span><br><span class="line">//查询此锁是否由任意线程保持。        </span><br><span class="line">boolean isLocked()</span><br></pre></td></tr></table></figure>
<h1 id="并发基础组件AQS与ReetrantLock"><a href="#并发基础组件AQS与ReetrantLock" class="headerlink" title="并发基础组件AQS与ReetrantLock"></a>并发基础组件AQS与ReetrantLock</h1><h1 id="AQS工作原理概要"><a href="#AQS工作原理概要" class="headerlink" title="AQS工作原理概要"></a>AQS工作原理概要</h1><p>AbstractQueuedSynchronizer又称为队列同步器(后面简称AQS)，它是用来构建锁或其他同步组件的基础框架，内部通过一个int类型的成员变量state来控制同步状态,当state=0时，则说明没有任何线程占有共享资源的锁，当state=1时，则说明有线程目前正在使用共享变量，其他线程必须加入同步队列进行等待，AQS内部通过内部类Node构成FIFO的同步队列来完成线程获取锁的排队工作，同时利用内部类ConditionObject构建等待队列，当Condition调用wait()方法后，线程将会加入等待队列中，而当Condition调用signal()方法后，线程将从等待队列转移动同步队列中进行锁竞争。注意这里涉及到两种队列，一种的同步队列，当线程请求锁而等待的后将加入同步队列等待，而另一种则是等待队列(可有多个)，通过Condition调用await()方法释放锁后，将加入等待队列。关于Condition的等待队列我们后面再分析，这里我们先来看看AQS中的同步队列模型，如下</p>
<ul>
<li>同步队列(竞争锁)</li>
<li>等待队列(await方法)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * AQS抽象类</span><br><span class="line"> */</span><br><span class="line">public abstract class AbstractQueuedSynchronizer</span><br><span class="line">    extends AbstractOwnableSynchronizer&#123;</span><br><span class="line">//指向同步队列队头</span><br><span class="line">private transient volatile Node head;</span><br><span class="line"></span><br><span class="line">//指向同步的队尾</span><br><span class="line">private transient volatile Node tail;</span><br><span class="line"></span><br><span class="line">//同步状态，0代表锁未被占用，1代表锁已被占用</span><br><span class="line">private volatile int state;</span><br><span class="line"></span><br><span class="line">//省略其他代码......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/pasted-66.png" alt="upload successful"></p>
<p>head和tail分别是AQS中的变量，其中head指向同步队列的头部，注意head为空结点，不存储信息。而tail则是同步队列的队尾，同步队列采用的是双向链表的结构这样可方便队列进行结点增删操作。state变量则是代表同步状态，执行当线程调用lock方法进行加锁后，如果此时state的值为0，则说明当前线程可以获取到锁(在本篇文章中，锁和同步状态代表同一个意思)，同时将state设置为1，表示获取成功。如果state已为1，也就是当前锁已被其他线程持有，那么当前执行线程将被封装为Node结点加入同步队列等待。其中Node结点是对每一个访问同步代码的线程的封装，从图中的Node的数据结构也可看出，其包含了需要同步的线程本身以及线程的状态，如是否被阻塞，是否等待唤醒，是否已经被取消等。每个Node结点内部关联其前继结点prev和后继结点next，这样可以方便线程释放锁后快速唤醒下一个在等待的线程，Node是AQS的内部类，其数据结构如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">static final class Node &#123;</span><br><span class="line">    //共享模式</span><br><span class="line">    static final Node SHARED = new Node();</span><br><span class="line">    //独占模式</span><br><span class="line">    static final Node EXCLUSIVE = null;</span><br><span class="line"></span><br><span class="line">    //标识线程已处于结束状态</span><br><span class="line">    static final int CANCELLED =  1;</span><br><span class="line">    //等待被唤醒状态</span><br><span class="line">    static final int SIGNAL    = -1;</span><br><span class="line">    //条件状态，</span><br><span class="line">    static final int CONDITION = -2;</span><br><span class="line">    //在共享模式中使用表示获得的同步状态会被传播</span><br><span class="line">    static final int PROPAGATE = -3;</span><br><span class="line"></span><br><span class="line">    //等待状态,存在CANCELLED、SIGNAL、CONDITION、PROPAGATE 4种</span><br><span class="line">    volatile int waitStatus;</span><br><span class="line"></span><br><span class="line">    //同步队列中前驱结点</span><br><span class="line">    volatile Node prev;</span><br><span class="line"></span><br><span class="line">    //同步队列中后继结点</span><br><span class="line">    volatile Node next;</span><br><span class="line"></span><br><span class="line">    //请求锁的线程</span><br><span class="line">    volatile Thread thread;</span><br><span class="line"></span><br><span class="line">    //等待队列中的后继结点，这个与Condition有关，稍后会分析</span><br><span class="line">    Node nextWaiter;</span><br><span class="line"></span><br><span class="line">    //判断是否为共享模式</span><br><span class="line">    final boolean isShared() &#123;</span><br><span class="line">        return nextWaiter == SHARED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //获取前驱结点</span><br><span class="line">    final Node predecessor() throws NullPointerException &#123;</span><br><span class="line">        Node p = prev;</span><br><span class="line">        if (p == null)</span><br><span class="line">            throw new NullPointerException();</span><br><span class="line">        else</span><br><span class="line">            return p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //.....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中SHARED和EXCLUSIVE常量分别代表共享模式和独占模式，所谓共享模式是一个锁允许多条线程同时操作，如信号量Semaphore采用的就是基于AQS的共享模式实现的，而独占模式则是同一个时间段只能有一个线程对共享资源进行操作，多余的请求线程需要排队等待，如ReentranLock。变量waitStatus则表示当前被封装成Node结点的等待状态，共有4种取值CANCELLED、SIGNAL、CONDITION、PROPAGATE。</p>
<p>CANCELLED：值为1，在同步队列中等待的线程等待超时或被中断，需要从同步队列中取消该Node的结点，其结点的waitStatus为CANCELLED，即结束状态，进入该状态后的结点将不会再变化。</p>
<p>SIGNAL：值为-1，被标识为该等待唤醒状态的后继结点，当其前继结点的线程释放了同步锁或被取消，将会通知该后继结点的线程执行。说白了，就是处于唤醒状态，只要前继结点释放锁，就会通知标识为SIGNAL状态的后继结点的线程执行。</p>
<p>CONDITION：值为-2，与Condition相关，该标识的结点处于等待队列中，结点的线程等待在Condition上，当其他线程调用了Condition的signal()方法后，CONDITION状态的结点将从等待队列转移到同步队列中，等待获取同步锁。</p>
<p>PROPAGATE：值为-3，与共享模式相关，在共享模式中，该状态标识结点的线程处于可运行状态。</p>
<p>0状态：值为0，代表初始化状态。</p>
<p>pre和next，分别指向当前Node结点的前驱结点和后继结点，thread变量存储的请求锁的线程。nextWaiter，与Condition相关，代表等待队列中的后继结点，关于这点这里暂不深入，后续会有更详细的分析，嗯，到此我们对Node结点的数据结构也就比较清晰了。总之呢，AQS作为基础组件，对于锁的实现存在两种不同的模式，即共享模式(如Semaphore)和独占模式(如ReetrantLock)，无论是共享模式还是独占模式的实现类，其内部都是基于AQS实现的，也都维持着一个虚拟的同步队列，当请求锁的线程超过现有模式的限制时，会将线程包装成Node结点并将线程当前必要的信息存储到node结点中，然后加入同步队列等会获取锁，而这系列操作都有AQS协助我们完成，这也是作为基础组件的原因，无论是Semaphore还是ReetrantLock，其内部绝大多数方法都是间接调用AQS完成的，下面是AQS整体类图结构</p>
<p><img src="/images/pasted-67.png" alt="upload successful"></p>
<p>这里以ReentrantLock为例，简单讲解ReentrantLock与AQS的关系</p>
<p><img src="/images/pasted-68.png" alt="upload successful"></p>
<ul>
<li><p>AbstractOwnableSynchronizer：抽象类，定义了存储独占当前锁的线程和获取的方法</p>
</li>
<li><p>AbstractQueuedSynchronizer：抽象类，AQS框架核心类，其内部以虚拟队列的方式管理线程的锁获取与锁释放，其中获取锁(tryAcquire方法)和释放锁(tryRelease方法)并没有提供默认实现，需要子类重写这两个方法实现具体逻辑，目的是使开发人员可以自由定义获取锁以及释放锁的方式。</p>
</li>
<li><p>Node：AbstractQueuedSynchronizer 的内部类，用于构建虚拟队列(链表双向链表)，管理需要获取锁的线程。</p>
</li>
<li><p>Sync：抽象类，是ReentrantLock的内部类，继承自AbstractQueuedSynchronizer，实现了释放锁的操作(tryRelease()方法)，并提供了lock抽象方法，由其子类实现。</p>
</li>
<li><p>NonfairSync：是ReentrantLock的内部类，继承自Sync，非公平锁的实现类。</p>
</li>
<li><p>FairSync：是ReentrantLock的内部类，继承自Sync，公平锁的实现类。</p>
</li>
<li><p>ReentrantLock：实现了Lock接口的，其内部类有Sync、NonfairSync、FairSync，在创建时可以根据fair参数决定创建NonfairSync(默认非公平锁)还是FairSync。</p>
</li>
</ul>
<p>ReentrantLock内部存在3个实现类，分别是Sync、NonfairSync、FairSync，其中Sync继承自AQS实现了解锁tryRelease()方法，而NonfairSync(非公平锁)、 FairSync(公平锁)则继承自Sync，实现了获取锁的tryAcquire()方法，ReentrantLock的所有方法调用都通过间接调用AQS和Sync类及其子类来完成的。从上述类图可以看出AQS是一个抽象类，但请注意其源码中并没一个抽象的方法，这是因为AQS只是作为一个基础组件，并不希望直接作为直接操作类对外输出，而更倾向于作为基础组件，为真正的实现类提供基础设施，如构建同步队列，控制同步状态等，事实上，从设计模式角度来看，AQS采用的模板模式的方式构建的，其内部除了提供并发操作核心方法以及同步队列操作外，还提供了一些模板方法让子类自己实现，如加锁操作以及解锁操作，为什么这么做？这是因为AQS作为基础组件，封装的是核心并发操作，但是实现上分为两种模式，即共享模式与独占模式，而这两种模式的加锁与解锁实现方式是不一样的，但AQS只关注内部公共方法实现并不关心外部不同模式的实现，所以提供了模板方法给子类使用，也就是说实现独占锁，如ReentrantLock需要自己实现tryAcquire()方法和tryRelease()方法，而实现共享模式的Semaphore，则需要实现tryAcquireShared()方法和tryReleaseShared()方法，这样做的好处是显而易见的，无论是共享模式还是独占模式，其基础的实现都是同一套组件(AQS)，只不过是加锁解锁的逻辑不同罢了，更重要的是如果我们需要自定义锁的话，也变得非常简单，只需要选择不同的模式实现不同的加锁和解锁的模板方法即可，AQS提供给独占模式和共享模式的模板方法如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">//AQS中提供的主要模板方法，由子类实现。</span><br><span class="line">public abstract class AbstractQueuedSynchronizer</span><br><span class="line">    extends AbstractOwnableSynchronizer&#123;</span><br><span class="line"></span><br><span class="line">    //独占模式下获取锁的方法</span><br><span class="line">    protected boolean tryAcquire(int arg) &#123;</span><br><span class="line">        throw new UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //独占模式下解锁的方法</span><br><span class="line">    protected boolean tryRelease(int arg) &#123;</span><br><span class="line">        throw new UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //共享模式下获取锁的方法</span><br><span class="line">    protected int tryAcquireShared(int arg) &#123;</span><br><span class="line">        throw new UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //共享模式下解锁的方法</span><br><span class="line">    protected boolean tryReleaseShared(int arg) &#123;</span><br><span class="line">        throw new UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line">    //判断是否为持有独占锁</span><br><span class="line">    protected boolean isHeldExclusively() &#123;</span><br><span class="line">        throw new UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="基于ReetrantLock分析AQS独占模式实现过程"><a href="#基于ReetrantLock分析AQS独占模式实现过程" class="headerlink" title="基于ReetrantLock分析AQS独占模式实现过程"></a>基于ReetrantLock分析AQS独占模式实现过程</h1><h2 id="ReetrantLock中非公平锁"><a href="#ReetrantLock中非公平锁" class="headerlink" title="ReetrantLock中非公平锁"></a>ReetrantLock中非公平锁</h2><p>AQS同步器的实现依赖于内部的同步队列(FIFO的双向链表对列)完成对同步状态(state)的管理，当前线程获取锁(同步状态)失败时，AQS会将该线程以及相关等待信息包装成一个节点(Node)并将其加入同步队列，同时会阻塞当前线程，当同步状态释放时，会将头结点head中的线程唤醒，让其尝试获取同步状态。关于同步队列和Node结点，前面我们已进行了较为详细的分析，这里重点分析一下获取同步状态和释放同步状态以及如何加入队列的具体操作，这里从ReetrantLock入手分析AQS的具体实现，我们先以非公平锁为例进行分析。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//默认构造，创建非公平锁NonfairSync</span><br><span class="line">public ReentrantLock() &#123;</span><br><span class="line">    sync = new NonfairSync();</span><br><span class="line">&#125;</span><br><span class="line">//根据传入参数创建锁类型</span><br><span class="line">public ReentrantLock(boolean fair) &#123;</span><br><span class="line">    sync = fair ? new FairSync() : new NonfairSync();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//加锁操作</span><br><span class="line">public void lock() &#123;</span><br><span class="line">     sync.lock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 非公平锁实现</span><br><span class="line"> */</span><br><span class="line">static final class NonfairSync extends Sync &#123;</span><br><span class="line">    //加锁</span><br><span class="line">    final void lock() &#123;</span><br><span class="line">        //执行CAS操作，获取同步状态</span><br><span class="line">        if (compareAndSetState(0, 1))</span><br><span class="line">       //成功则将独占锁线程设置为当前线程  </span><br><span class="line">          setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">        else</span><br><span class="line">            //否则再次请求同步状态</span><br><span class="line">            acquire(1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 公平锁实现</span><br><span class="line"> */</span><br><span class="line">static final class FairSync extends Sync &#123;</span><br><span class="line">      private static final long serialVersionUID = -3000897897090466540L;</span><br><span class="line"></span><br><span class="line">      final void lock() &#123;</span><br><span class="line">          acquire(1);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>这里获取锁时，首先对同步状态执行CAS操作，尝试把state的状态从0设置为1，如果返回true则代表获取同步状态成功，也就是当前线程获取锁成，可操作临界资源，如果返回false，则表示已有线程持有该同步状态(其值为1)，获取锁失败，注意这里存在并发的情景，也就是可能同时存在多个线程设置state变量，因此是CAS操作保证了state变量操作的原子性。返回false后，执行 acquire(1)方法，该方法是AQS中的方法，它对中断不敏感，即使线程获取同步状态失败，进入同步队列，后续对该线程执行中断操作也不会从同步队列中移出，方法如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public final void acquire(int arg) &#123;</span><br><span class="line">    //再次尝试获取同步状态</span><br><span class="line">    if (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里传入参数arg表示要获取同步状态后设置的值(即要设置state的值)，因为要获取锁，而status为0时是释放锁，1则是获取锁，所以这里一般传递参数为1，进入方法后首先会执行tryAcquire(arg)方法，在前面分析过该方法在AQS中并没有具体实现，而是交由子类实现，因此该方法是由ReetrantLock类内部实现的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//NonfairSync类</span><br><span class="line">static final class NonfairSync extends Sync &#123;</span><br><span class="line"></span><br><span class="line">    protected final boolean tryAcquire(int acquires) &#123;</span><br><span class="line">         return nonfairTryAcquire(acquires);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">//Sync类</span><br><span class="line">abstract static class Sync extends AbstractQueuedSynchronizer &#123;</span><br><span class="line"></span><br><span class="line">  //nonfairTryAcquire方法</span><br><span class="line">  final boolean nonfairTryAcquire(int acquires) &#123;</span><br><span class="line">      final Thread current = Thread.currentThread();</span><br><span class="line">      int c = getState();</span><br><span class="line">      //判断同步状态是否为0，并尝试再次获取同步状态</span><br><span class="line">      if (c == 0) &#123;</span><br><span class="line">          //执行CAS操作</span><br><span class="line">          if (compareAndSetState(0, acquires)) &#123;</span><br><span class="line">              setExclusiveOwnerThread(current);</span><br><span class="line">              return true;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      //如果当前线程已获取锁，属于重入锁，再次获取锁后将status值加1</span><br><span class="line">      else if (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">          int nextc = c + acquires;</span><br><span class="line">          if (nextc &lt; 0) // overflow</span><br><span class="line">              throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">          //设置当前同步状态，当前只有一个线程持有锁，因为不会发生线程安全问题，可以直接执行 setState(nextc);</span><br><span class="line">          setState(nextc);</span><br><span class="line">          return true;</span><br><span class="line">      &#125;</span><br><span class="line">      return false;</span><br><span class="line">  &#125;</span><br><span class="line">  //省略其他代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从代码执行流程可以看出，这里做了两件事，一是尝试再次获取同步状态，如果获取成功则将当前线程设置为OwnerThread，否则失败，二是判断当前线程current是否为OwnerThread，如果是则属于重入锁，state自增1，并获取锁成功，返回true，反之失败，返回false，也就是tryAcquire(arg)执行失败，返回false。需要注意的是nonfairTryAcquire(int acquires)内部使用的是CAS原子性操作设置state值，可以保证state的更改是线程安全的，因此只要任意一个线程调用nonfairTryAcquire(int acquires)方法并设置成功即可获取锁，不管该线程是新到来的还是已在同步队列的线程，毕竟这是非公平锁，并不保证同步队列中的线程一定比新到来线程请求(可能是head结点刚释放同步状态然后新到来的线程恰好获取到同步状态)先获取到锁，这点跟后面还会讲到的公平锁不同。ok~，接着看之前的方法acquire(int arg)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public final void acquire(int arg) &#123;</span><br><span class="line">    //再次尝试获取同步状态</span><br><span class="line">    if (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果tryAcquire(arg)返回true，acquireQueued自然不会执行，这是最理想的，因为毕竟当前线程已获取到锁，如果tryAcquire(arg)返回false，则会执行addWaiter(Node.EXCLUSIVE)进行入队操作,由于ReentrantLock属于独占锁，因此结点类型为Node.EXCLUSIVE，下面看看addWaiter方法具体实现（先执行里面的方法）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">private Node addWaiter(Node mode) &#123;</span><br><span class="line">    //将请求同步状态失败的线程封装成结点</span><br><span class="line">    Node node = new Node(Thread.currentThread(), mode);</span><br><span class="line"></span><br><span class="line">    Node pred = tail;</span><br><span class="line">    //如果是第一个结点加入肯定为空，跳过。</span><br><span class="line">    //如果非第一个结点则直接执行CAS入队操作，尝试在尾部快速添加</span><br><span class="line">    if (pred != null) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        //使用CAS执行尾部结点替换，尝试在尾部快速添加</span><br><span class="line">        if (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            return node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //如果第一次加入或者CAS操作没有成功执行enq入队操作</span><br><span class="line">    enq(node);</span><br><span class="line">    return node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建了一个Node.EXCLUSIVE类型Node结点用于封装线程及其相关信息，其中tail是AQS的成员变量，指向队尾(这点前面的我们分析过AQS维持的是一个双向的链表结构同步队列)，如果是第一个结点，则为tail肯定为空，那么将执行enq(node)操作，如果非第一个结点即tail指向不为null，直接尝试执行CAS操作加入队尾，如果CAS操作失败还是会执行enq(node)，继续看enq(node)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">private Node enq(final Node node) &#123;</span><br><span class="line">    //死循环</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">         Node t = tail;</span><br><span class="line">         //如果队列为null，即没有头结点</span><br><span class="line">         if (t == null) &#123; // Must initialize</span><br><span class="line">             //创建并使用CAS设置头结点</span><br><span class="line">             if (compareAndSetHead(new Node()))</span><br><span class="line">                 tail = head;</span><br><span class="line">         &#125; else &#123;//队尾添加新结点</span><br><span class="line">             node.prev = t;</span><br><span class="line">             if (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                 t.next = node;</span><br><span class="line">                 return t;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这个方法使用一个死循环进行CAS操作，可以解决多线程并发问题。这里做了两件事，一是如果还没有初始同步队列则创建新结点并使用compareAndSetHead设置头结点，tail也指向head，二是队列已存在，则将新结点node添加到队尾。注意这两个步骤都存在同一时间多个线程操作的可能，如果有一个线程修改head和tail成功，那么其他线程将继续循环，直到修改成功，这里使用CAS原子操作进行头结点设置和尾结点tail替换可以保证线程安全，从这里也可以看出head结点本身不存在任何数据，它只是作为一个牵头结点，而tail永远指向尾部结点(前提是队列不为null)。</p>
<p><img src="/images/pasted-69.png" alt="upload successful"></p>
<p>添加到同步队列后，结点就会进入一个自旋过程，即每个结点都在观察时机待条件满足获取同步状态，然后从同步队列退出并结束自旋，回到之前的acquire()方法，自旋过程是在acquireQueued(addWaiter(Node.EXCLUSIVE), arg))方法中执行的，代码如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">final boolean acquireQueued(final Node node, int arg) &#123;</span><br><span class="line">    boolean failed = true;</span><br><span class="line">    try &#123;</span><br><span class="line">        boolean interrupted = false;</span><br><span class="line">        //自旋，死循环</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            //获取前驱结点</span><br><span class="line">            final Node p = node.predecessor();</span><br><span class="line">            当且仅当p为头结点才尝试获取同步状态</span><br><span class="line">            if (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                //将node设置为头结点</span><br><span class="line">                setHead(node);</span><br><span class="line">                //清空原来头结点的引用便于GC</span><br><span class="line">                p.next = null; // help GC</span><br><span class="line">                failed = false;</span><br><span class="line">                return interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            //如果前驱结点不是head，判断是否挂起线程</span><br><span class="line">            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (failed)</span><br><span class="line">            //最终都没能获取同步状态，结束该线程的请求</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当前线程在自旋(死循环)中获取同步状态，当且仅当前驱结点为头结点才尝试获取同步状态，这符合FIFO的规则，即先进先出，其次head是当前获取同步状态的线程结点，只有当head释放同步状态唤醒后继结点，后继结点才有可能获取到同步状态，因此后继结点在其前继结点为head时，才进行尝试获取同步状态，其他时刻将被挂起。进入if语句后调用setHead(node)方法，将当前线程结点设置为head</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//设置为头结点</span><br><span class="line">private void setHead(Node node) &#123;</span><br><span class="line">        head = node;</span><br><span class="line">        //清空结点数据</span><br><span class="line">        node.thread = null;</span><br><span class="line">        node.prev = null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>设置为node结点被设置为head后，其thread信息和前驱结点将被清空，因为该线程已获取到同步状态(锁)，正在执行了，也就没有必要存储相关信息了，head只有保存指向后继结点的指针即可，便于head结点释放同步状态后唤醒后继结点，执行结果如下图</p>
<p><img src="/images/pasted-70.png" alt="upload successful"></p>
<p>从图可知更新head结点的指向，将后继结点的线程唤醒并获取同步状态，调用setHead(node)将其替换为head结点，清除相关无用数据。当然如果前驱结点不是head，那么执行如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">//如果前驱结点不是head，判断是否挂起线程</span><br><span class="line">if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;parkAndCheckInterrupt())</span><br><span class="line"></span><br><span class="line">      interrupted = true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) &#123;</span><br><span class="line">        //获取当前结点的等待状态</span><br><span class="line">        int ws = pred.waitStatus;</span><br><span class="line">        //如果为等待唤醒（SIGNAL）状态则返回true</span><br><span class="line">        if (ws == Node.SIGNAL)</span><br><span class="line">            return true;</span><br><span class="line">        //如果ws&gt;0 则说明是结束状态，</span><br><span class="line">        //遍历前驱结点直到找到没有结束状态的结点</span><br><span class="line">        if (ws &gt; 0) &#123;</span><br><span class="line">            do &#123;</span><br><span class="line">                node.prev = pred = pred.prev;</span><br><span class="line">            &#125; while (pred.waitStatus &gt; 0);</span><br><span class="line">            pred.next = node;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //如果ws小于0又不是SIGNAL状态，</span><br><span class="line">            //则将其设置为SIGNAL状态，代表该结点的线程正在等待唤醒。</span><br><span class="line">            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private final boolean parkAndCheckInterrupt() &#123;</span><br><span class="line">        //将当前线程挂起</span><br><span class="line">        LockSupport.park(this);</span><br><span class="line">        //获取线程中断状态,interrupted()是判断当前中断状态，</span><br><span class="line">        //并非中断线程，因此可能true也可能false,并返回</span><br><span class="line">        return Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>shouldParkAfterFailedAcquire()方法的作用是判断当前结点的前驱结点是否为SIGNAL状态(即等待唤醒状态)，如果是则返回true。如果结点的ws为CANCELLED状态(值为1&gt;0),即结束状态，则说明该前驱结点已没有用应该从同步队列移除，执行while循环，直到寻找到非CANCELLED状态的结点。倘若前驱结点的ws值不为CANCELLED，也不为SIGNAL(当从Condition的条件等待队列转移到同步队列时，结点状态为CONDITION因此需要转换为SIGNAL)，那么将其转换为SIGNAL状态，等待被唤醒。<br>若shouldParkAfterFailedAcquire()方法返回true，即前驱结点为SIGNAL状态同时又不是head结点，那么使用parkAndCheckInterrupt()方法挂起当前线程，称为WAITING状态，需要等待一个unpark()操作来唤醒它，到此ReetrantLock内部间接通过AQS的FIFO的同步队列就完成了lock()操作，这里我们总结成逻辑流程图</p>
<p><img src="/images/pasted-71.png" alt="upload successful"></p>
<p>关于获取锁的操作，这里看看另外一种可中断的获取方式，即调用ReentrantLock类的lockInterruptibly()或者tryLock()方法，最终它们都间接调用到doAcquireInterruptibly()</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">private void doAcquireInterruptibly(int arg)</span><br><span class="line">        throws InterruptedException &#123;</span><br><span class="line">        final Node node = addWaiter(Node.EXCLUSIVE);</span><br><span class="line">        boolean failed = true;</span><br><span class="line">        try &#123;</span><br><span class="line">            for (;;) &#123;</span><br><span class="line">                final Node p = node.predecessor();</span><br><span class="line">                if (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                    setHead(node);</span><br><span class="line">                    p.next = null; // help GC</span><br><span class="line">                    failed = false;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">                if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    //直接抛异常，中断线程的同步状态请求</span><br><span class="line">                    throw new InterruptedException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            if (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>最大的不同是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">     //直接抛异常，中断线程的同步状态请求</span><br><span class="line">       throw new InterruptedException();</span><br></pre></td></tr></table></figure></p>
<p>检测到线程的中断操作后，直接抛出异常，从而中断线程的同步状态请求，移除同步队列，ok~,加锁流程到此。下面接着看unlock()操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">//ReentrantLock类的unlock</span><br><span class="line">public void unlock() &#123;</span><br><span class="line">    sync.release(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//AQS类的release()方法</span><br><span class="line">public final boolean release(int arg) &#123;</span><br><span class="line">    //尝试释放锁</span><br><span class="line">    if (tryRelease(arg)) &#123;</span><br><span class="line"></span><br><span class="line">        Node h = head;</span><br><span class="line">        if (h != null &amp;&amp; h.waitStatus != 0)</span><br><span class="line">            //唤醒后继结点的线程</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//ReentrantLock类中的内部类Sync实现的tryRelease(int releases)</span><br><span class="line">protected final boolean tryRelease(int releases) &#123;</span><br><span class="line"></span><br><span class="line">      int c = getState() - releases;</span><br><span class="line">      if (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">          throw new IllegalMonitorStateException();</span><br><span class="line">      boolean free = false;</span><br><span class="line">      //判断状态是否为0，如果是则说明已释放同步状态</span><br><span class="line">      if (c == 0) &#123;</span><br><span class="line">          free = true;</span><br><span class="line">          //设置Owner为null</span><br><span class="line">          setExclusiveOwnerThread(null);</span><br><span class="line">      &#125;</span><br><span class="line">      //设置更新同步状态</span><br><span class="line">      setState(c);</span><br><span class="line">      return free;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>释放同步状态的操作相对简单些，tryRelease(int releases)方法是ReentrantLock类中内部类自己实现的，因为AQS对于释放锁并没有提供具体实现，必须由子类自己实现。释放同步状态后会使用unparkSuccessor(h)唤醒后继结点的线程，这里看看unparkSuccessor(h)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">private void unparkSuccessor(Node node) &#123;</span><br><span class="line">    //这里，node一般为当前线程所在的结点。</span><br><span class="line">    int ws = node.waitStatus;</span><br><span class="line">    if (ws &lt; 0)//置零当前线程所在的结点状态，允许失败。</span><br><span class="line">        compareAndSetWaitStatus(node, ws, 0);</span><br><span class="line"></span><br><span class="line">    Node s = node.next;//找到下一个需要唤醒的结点s</span><br><span class="line">    if (s == null || s.waitStatus &gt; 0) &#123;//如果为空或已取消</span><br><span class="line">        s = null;</span><br><span class="line">        for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            if (t.waitStatus &lt;= 0)//从这里可以看出，&lt;=0的结点，都是还有效的结点。</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    if (s != null)</span><br><span class="line">        LockSupport.unpark(s.thread);//唤醒</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从代码执行操作来看，这里主要作用是用unpark()唤醒同步队列中最前边未放弃线程(也就是状态为CANCELLED的线程结点s)。此时，回忆前面分析进入自旋的函数acquireQueued()，s结点的线程被唤醒后，会进入acquireQueued()函数的if (p == head &amp;&amp; tryAcquire(arg))的判断，如果p!=head也不会有影响，因为它会执行shouldParkAfterFailedAcquire()，由于s通过unparkSuccessor()操作后已是同步队列中最前边未放弃的线程结点，那么通过shouldParkAfterFailedAcquire()内部对结点状态的调整，s也必然会成为head的next结点，因此再次自旋时p==head就成立了，然后s把自己设置成head结点，表示自己已经获取到资源了，最终acquire()也返回了，这就是独占锁释放的过程。<br>ok~，关于独占模式的加锁和释放锁的过程到这就分析完，总之呢，在AQS同步器中维护着一个同步队列，当线程获取同步状态失败后，将会被封装成Node结点，加入到同步队列中并进行自旋操作，当当前线程结点的前驱结点为head时，将尝试获取同步状态，获取成功将自己设置为head结点。在释放同步状态时，则通过调用子类(ReetrantLock中的Sync内部类)的tryRelease(int releases)方法释放同步状态，释放成功则唤醒后继结点的线程。</p>
<h2 id="ReetrantLock中公平锁"><a href="#ReetrantLock中公平锁" class="headerlink" title="ReetrantLock中公平锁"></a>ReetrantLock中公平锁</h2><p>了解完ReetrantLock中非公平锁的实现后，我们再来看看公平锁。与非公平锁不同的是，在获取锁的时，公平锁的获取顺序是完全遵循时间上的FIFO规则，也就是说先请求的线程一定会先获取锁，后来的线程肯定需要排队，这点与前面我们分析非公平锁的nonfairTryAcquire(int acquires)方法实现有锁不同，下面是公平锁中tryAcquire()方法的实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//公平锁FairSync类中的实现</span><br><span class="line">protected final boolean tryAcquire(int acquires) &#123;</span><br><span class="line">            final Thread current = Thread.currentThread();</span><br><span class="line">            int c = getState();</span><br><span class="line">            if (c == 0) &#123;</span><br><span class="line">            //注意！！这里先判断同步队列是否存在结点</span><br><span class="line">                if (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                    compareAndSetState(0, acquires)) &#123;</span><br><span class="line">                    setExclusiveOwnerThread(current);</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">                int nextc = c + acquires;</span><br><span class="line">                if (nextc &lt; 0)</span><br><span class="line">                    throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">                setState(nextc);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>该方法与nonfairTryAcquire(int acquires)方法唯一的不同是在使用CAS设置尝试设置state值前，调用了hasQueuedPredecessors()判断同步队列是否存在结点，如果存在必须先执行完同步队列中结点的线程，当前线程进入等待状态。这就是非公平锁与公平锁最大的区别，即公平锁在线程请求到来时先会判断同步队列是否存在结点，如果存在先执行同步队列中的结点线程，当前线程将封装成node加入同步队列等待。而非公平锁呢，当线程请求到来时，不管同步队列是否存在线程结点，直接尝试获取同步状态，获取成功直接访问共享资源，但请注意在绝大多数情况下，非公平锁才是我们理想的选择，毕竟从效率上来说非公平锁总是胜于公平锁。<br>    以上便是ReentrantLock的内部实现原理，这里我们简单进行小结，重入锁ReentrantLock，是一个基于AQS并发框架的并发控制类，其内部实现了3个类，分别是Sync、NoFairSync以及FairSync类，其中Sync继承自AQS，实现了释放锁的模板方法tryRelease(int)，而NoFairSync和FairSync都继承自Sync，实现各种获取锁的方法tryAcquire(int)。ReentrantLock的所有方法实现几乎都间接调用了这3个类，因此当我们在使用ReentrantLock时，大部分使用都是在间接调用AQS同步器中的方法，这就是ReentrantLock的内部实现原理,最后给出张类图结构</p>
<p><img src="/images/pasted-72.png" alt="upload successful"></p>
<h2 id="关于synchronized-与ReentrantLock"><a href="#关于synchronized-与ReentrantLock" class="headerlink" title="关于synchronized 与ReentrantLock"></a>关于synchronized 与ReentrantLock</h2><p>在JDK 1.6之后，虚拟机对于synchronized关键字进行整体优化后，在性能上synchronized与ReentrantLock已没有明显差距，因此在使用选择上，需要根据场景而定，大部分情况下我们依然建议是synchronized关键字，原因之一是使用方便语义清晰，二是性能上虚拟机已为我们自动优化。而ReentrantLock提供了多样化的同步特性，如超时获取锁、可以被中断获取锁（synchronized的同步是不能中断的）、等待唤醒机制的多个条件变量(Condition)等，因此当我们确实需要使用到这些功能是，可以选择ReentrantLock</p>
<p>ReentrantLock:</p>
<ul>
<li>超时获取锁</li>
<li>可以被中断获取锁（synchronized的同步是不能中断的）</li>
<li>等待唤醒机制的多条件变量</li>
</ul>
<h1 id="神奇的Condition"><a href="#神奇的Condition" class="headerlink" title="神奇的Condition"></a>神奇的Condition</h1><h2 id="关于Condition接口"><a href="#关于Condition接口" class="headerlink" title="关于Condition接口"></a>关于Condition接口</h2><p>在并发编程中，每个Java对象都存在一组监视器方法，如wait()、notify()以及notifyAll()方法，通过这些方法，我们可以实现线程间通信与协作（也称为等待唤醒机制），如生产者-消费者模式，而且这些方法必须配合着synchronized关键字使用，关于这点，如果想有更深入的理解，可观看博主另外一篇博文【 深入理解Java并发之synchronized实现原理】，与synchronized的等待唤醒机制相比Condition具有更多的灵活性以及精确性，这是因为notify()在唤醒线程时是随机(同一个锁)，而Condition则可通过多个Condition实例对象建立更加精细的线程控制，也就带来了更多灵活性了，我们可以简单理解为以下两点</p>
<ul>
<li><p>通过Condition能够精细的控制多线程的休眠与唤醒。</p>
</li>
<li><p>对于一个锁，我们可以为多个线程间建立不同的Condition。</p>
</li>
</ul>
<p>Condition是一个接口类，其主要方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public interface Condition &#123;</span><br><span class="line"></span><br><span class="line"> /**</span><br><span class="line">  * 使当前线程进入等待状态直到被通知(signal)或中断</span><br><span class="line">  * 当其他线程调用singal()或singalAll()方法时，该线程将被唤醒</span><br><span class="line">  * 当其他线程调用interrupt()方法中断当前线程</span><br><span class="line">  * await()相当于synchronized等待唤醒机制中的wait()方法</span><br><span class="line">  */</span><br><span class="line"> void await() throws InterruptedException;</span><br><span class="line"></span><br><span class="line"> //当前线程进入等待状态，直到被唤醒，该方法不响应中断要求</span><br><span class="line"> void awaitUninterruptibly();</span><br><span class="line"></span><br><span class="line"> //调用该方法，当前线程进入等待状态，直到被唤醒或被中断或超时</span><br><span class="line"> //其中nanosTimeout指的等待超时时间，单位纳秒</span><br><span class="line"> long awaitNanos(long nanosTimeout) throws InterruptedException;</span><br><span class="line"></span><br><span class="line">  //同awaitNanos，但可以指明时间单位</span><br><span class="line">  boolean await(long time, TimeUnit unit) throws InterruptedException;</span><br><span class="line"></span><br><span class="line"> //调用该方法当前线程进入等待状态，直到被唤醒、中断或到达某个时</span><br><span class="line"> //间期限(deadline),如果没到指定时间就被唤醒，返回true，其他情况返回false</span><br><span class="line">  boolean awaitUntil(Date deadline) throws InterruptedException;</span><br><span class="line"></span><br><span class="line"> //唤醒一个等待在Condition上的线程，该线程从等待方法返回前必须</span><br><span class="line"> //获取与Condition相关联的锁，功能与notify()相同</span><br><span class="line">  void signal();</span><br><span class="line"></span><br><span class="line"> //唤醒所有等待在Condition上的线程，该线程从等待方法返回前必须</span><br><span class="line"> //获取与Condition相关联的锁，功能与notifyAll()相同</span><br><span class="line">  void signalAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于Condition的实现类是AQS的内部类ConditionObject，关于这点我们稍后分析，这里先来看一个Condition的使用案例，即经典消费者生产者模式</p>
<h2 id="Condition的使用案例-生产者消费者模式"><a href="#Condition的使用案例-生产者消费者模式" class="headerlink" title="Condition的使用案例-生产者消费者模式"></a>Condition的使用案例-生产者消费者模式</h2><p><code>conditon使唤醒的更加精细,更目标化</code></p>
<p>这里我们通过一个卖烤鸭的案例来演示多生产多消费者的案例，该场景中存在两条生产线程t1和t2，用于生产烤鸭，也存在两条消费线程t3，t4用于消费烤鸭，4条线程同时执行，需要保证只有在生产线程产生烤鸭后，消费线程才能消费，否则只能等待，直到生产线程产生烤鸭后唤醒消费线程，注意烤鸭不能重复消费。ResourceByCondition类中定义product()和consume()两个方法，分别用于生产烤鸭和消费烤鸭，并且定义ReentrantLock锁，用于控制product()和consume()的并发，由于必须在烤鸭生成完成后消费线程才能消费烤鸭，否则只能等待，因此这里定义两组Condition对象，分别是producer_con和consumer_con，前者拥有控制生产线程，后者拥有控制消费线程，这里我们使用一个标志flag来控制是否有烤鸭，当flag为true时，代表烤鸭生成完毕，生产线程必须进入等待状态同时唤醒消费线程进行消费，消费线程消费完毕后将flag设置为false，代表烤鸭消费完成，进入等待状态，同时唤醒生产线程生产烤鸭，具体代码如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line">package com.zejian.concurrencys;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.locks.Condition;</span><br><span class="line">import java.util.concurrent.locks.Lock;</span><br><span class="line">import java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Created by zejian on 2017/7/22.</span><br><span class="line"> * Blog : http://blog.csdn.net/javazejian [原文地址,请尊重原创]</span><br><span class="line"> */</span><br><span class="line">public class ResourceByCondition &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int count = 1;</span><br><span class="line">    private boolean flag = false;</span><br><span class="line"></span><br><span class="line">    //创建一个锁对象。</span><br><span class="line">    Lock lock = new ReentrantLock();</span><br><span class="line"></span><br><span class="line">    //通过已有的锁获取两组监视器，一组监视生产者，一组监视消费者。</span><br><span class="line">    Condition producer_con = lock.newCondition();</span><br><span class="line">    Condition consumer_con = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 生产</span><br><span class="line">     * @param name</span><br><span class="line">     */</span><br><span class="line">    public  void product(String name)</span><br><span class="line">    &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try</span><br><span class="line">        &#123;</span><br><span class="line">            while(flag)&#123;</span><br><span class="line">                try&#123;producer_con.await();&#125;catch(InterruptedException e)&#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">            this.name = name + count;</span><br><span class="line">            count++;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+&quot;...生产者5.0...&quot;+this.name);</span><br><span class="line">            flag = true;</span><br><span class="line">            consumer_con.signal();//直接唤醒消费线程</span><br><span class="line">        &#125;</span><br><span class="line">        finally</span><br><span class="line">        &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 消费</span><br><span class="line">     */</span><br><span class="line">    public  void consume()</span><br><span class="line">    &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try</span><br><span class="line">        &#123;</span><br><span class="line">            while(!flag)&#123;</span><br><span class="line">                try&#123;consumer_con.await();&#125;catch(InterruptedException e)&#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+&quot;...消费者.5.0.......&quot;+this.name);//消费烤鸭1</span><br><span class="line">            flag = false;</span><br><span class="line">            producer_con.signal();//直接唤醒生产线程</span><br><span class="line">        &#125;</span><br><span class="line">        finally</span><br><span class="line">        &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">执行代码</span><br><span class="line"></span><br><span class="line">package com.zejian.concurrencys;</span><br><span class="line">/**</span><br><span class="line"> * Created by zejian on 2017/7/22.</span><br><span class="line"> * Blog : http://blog.csdn.net/javazejian [原文地址,请尊重原创]</span><br><span class="line"> */</span><br><span class="line">public class Mutil_Producer_ConsumerByCondition &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ResourceByCondition r = new ResourceByCondition();</span><br><span class="line">        Mutil_Producer pro = new Mutil_Producer(r);</span><br><span class="line">        Mutil_Consumer con = new Mutil_Consumer(r);</span><br><span class="line">        //生产者线程</span><br><span class="line">        Thread t0 = new Thread(pro);</span><br><span class="line">        Thread t1 = new Thread(pro);</span><br><span class="line">        //消费者线程</span><br><span class="line">        Thread t2 = new Thread(con);</span><br><span class="line">        Thread t3 = new Thread(con);</span><br><span class="line">        //启动线程</span><br><span class="line">        t0.start();</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @decrition 生产者线程</span><br><span class="line"> */</span><br><span class="line">class Mutil_Producer implements Runnable &#123;</span><br><span class="line">    private ResourceByCondition r;</span><br><span class="line"></span><br><span class="line">    Mutil_Producer(ResourceByCondition r) &#123;</span><br><span class="line">        this.r = r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void run() &#123;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            r.product(&quot;北京烤鸭&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @decrition 消费者线程</span><br><span class="line"> */</span><br><span class="line">class Mutil_Consumer implements Runnable &#123;</span><br><span class="line">    private ResourceByCondition r;</span><br><span class="line"></span><br><span class="line">    Mutil_Consumer(ResourceByCondition r) &#123;</span><br><span class="line">        this.r = r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void run() &#123;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            r.consume();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>正如代码所示，我们通过两者Condition对象单独控制消费线程与生产消费，这样可以避免消费线程在唤醒线程时唤醒的还是消费线程，如果是通过synchronized的等待唤醒机制实现的话，就可能无法避免这种情况，毕竟同一个锁，对于synchronized关键字来说只能有一组等待唤醒队列，而不能像Condition一样，同一个锁拥有多个等待队列。synchronized的实现方案如下，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public class KaoYaResource &#123;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line">    private int count = 1;//烤鸭的初始数量</span><br><span class="line">    private boolean flag = false;//判断是否有需要线程等待的标志</span><br><span class="line">    /**</span><br><span class="line">     * 生产烤鸭</span><br><span class="line">     */</span><br><span class="line">    public synchronized void product(String name)&#123;</span><br><span class="line">        while(flag)&#123;</span><br><span class="line">            //此时有烤鸭，等待</span><br><span class="line">            try &#123;</span><br><span class="line">                this.wait();</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        this.name=name+count;//设置烤鸭的名称</span><br><span class="line">        count++;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+&quot;...生产者...&quot;+this.name);</span><br><span class="line">        flag=true;//有烤鸭后改变标志</span><br><span class="line">        notifyAll();//通知消费线程可以消费了</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 消费烤鸭</span><br><span class="line">     */</span><br><span class="line">    public synchronized void consume()&#123;</span><br><span class="line">        while(!flag)&#123;//如果没有烤鸭就等待</span><br><span class="line">            try&#123;this.wait();&#125;catch(InterruptedException e)&#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+&quot;...消费者........&quot;+this.name);//消费烤鸭1</span><br><span class="line">        flag = false;</span><br><span class="line">        notifyAll();//通知生产者生产烤鸭</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上代码，在调用notify()或者 notifyAll()方法时，由于等待队列中同时存在生产者线程和消费者线程，所以我们并不能保证被唤醒的到底是消费者线程还是生产者线程，而Codition则可以避免这种情况。嗯，了解完Condition的使用方式后，下面我们将进一步探讨Condition背后的实现机制</p>
<h2 id="Condition的实现原理"><a href="#Condition的实现原理" class="headerlink" title="Condition的实现原理"></a>Condition的实现原理</h2><p>Condition的具体实现类是AQS的内部类ConditionObject，前面我们分析过AQS中存在两种队列，一种是同步队列，一种是等待队列，而等待队列就相对于Condition而言的。注意在使用Condition前必须获得锁，同时在Condition的等待队列上的结点与前面同步队列的结点是同一个类即Node，其结点的waitStatus的值为CONDITION。在实现类ConditionObject中有两个结点分别是firstWaiter和lastWaiter，firstWaiter代表等待队列第一个等待结点，lastWaiter代表等待队列最后一个等待结点，如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> public class ConditionObject implements Condition, java.io.Serializable &#123;</span><br><span class="line">    //等待队列第一个等待结点</span><br><span class="line">    private transient Node firstWaiter;</span><br><span class="line">    //等待队列最后一个等待结点</span><br><span class="line">    private transient Node lastWaiter;</span><br><span class="line">    //省略其他代码.......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每个Condition都对应着一个等待队列，也就是说如果一个锁上创建了多个Condition对象，那么也就存在多个等待队列。等待队列是一个FIFO的队列，在队列中每一个节点都包含了一个线程的引用，而该线程就是Condition对象上等待的线程。当一个线程调用了await()相关的方法，那么该线程将会释放锁，并构建一个Node节点封装当前线程的相关信息加入到等待队列中进行等待，直到被唤醒、中断、超时才从队列中移出。Condition中的等待队列模型如下</p>
<p><img src="/images/pasted-73.png" alt="upload successful"></p>
<p>正如图所示，Node节点的数据结构，在等待队列中使用的变量与同步队列是不同的，Condtion中等待队列的结点只有直接指向的后继结点并没有指明前驱结点，而且使用的变量是nextWaiter而不是next，这点我们在前面分析结点Node的数据结构时讲过。firstWaiter指向等待队列的头结点，lastWaiter指向等待队列的尾结点，等待队列中结点的状态只有两种即CANCELLED和CONDITION，前者表示线程已结束需要从等待队列中移除，后者表示条件结点等待被唤醒。再次强调每个Codition对象对于一个等待队列，也就是说AQS中只能存在一个同步队列，但可拥有多个等待队列。下面从代码层面看看被调用await()方法(其他await()实现原理类似)的线程是如何加入等待队列的，而又是如何从等待队列中被唤醒的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public final void await() throws InterruptedException &#123;</span><br><span class="line">      //判断线程是否被中断</span><br><span class="line">      if (Thread.interrupted())</span><br><span class="line">          throw new InterruptedException();</span><br><span class="line">      //创建新结点加入等待队列并返回</span><br><span class="line">      Node node = addConditionWaiter();</span><br><span class="line">      //释放当前线程锁即释放同步状态</span><br><span class="line">      int savedState = fullyRelease(node);</span><br><span class="line">      int interruptMode = 0;</span><br><span class="line">      //判断结点是否同步队列(SyncQueue)中,即是否被唤醒</span><br><span class="line">      while (!isOnSyncQueue(node)) &#123;</span><br><span class="line">          //挂起线程</span><br><span class="line">          LockSupport.park(this);</span><br><span class="line">          //判断是否被中断唤醒，如果是退出循环。</span><br><span class="line">          if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)</span><br><span class="line">              break;</span><br><span class="line">      &#125;</span><br><span class="line">      //被唤醒后执行自旋操作争取获得锁，同时判断线程是否被中断</span><br><span class="line">      if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">          interruptMode = REINTERRUPT;</span><br><span class="line">       // clean up if cancelled</span><br><span class="line">      if (node.nextWaiter != null)</span><br><span class="line">          //清理等待队列中不为CONDITION状态的结点</span><br><span class="line">          unlinkCancelledWaiters();</span><br><span class="line">      if (interruptMode != 0)</span><br><span class="line">          reportInterruptAfterWait(interruptMode);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>执行addConditionWaiter()添加到等待队列。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">private Node addConditionWaiter() &#123;</span><br><span class="line">    Node t = lastWaiter;</span><br><span class="line">      // 判断是否为结束状态的结点并移除</span><br><span class="line">      if (t != null &amp;&amp; t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">          unlinkCancelledWaiters();</span><br><span class="line">          t = lastWaiter;</span><br><span class="line">      &#125;</span><br><span class="line">      //创建新结点状态为CONDITION</span><br><span class="line">      Node node = new Node(Thread.currentThread(), Node.CONDITION);</span><br><span class="line">      //加入等待队列</span><br><span class="line">      if (t == null)</span><br><span class="line">          firstWaiter = node;</span><br><span class="line">      else</span><br><span class="line">          t.nextWaiter = node;</span><br><span class="line">      lastWaiter = node;</span><br><span class="line">      return node;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>await()方法主要做了3件事，一是调用addConditionWaiter()方法将当前线程封装成node结点加入等待队列，二是调用fullyRelease(node)方法释放同步状态并唤醒后继结点的线程。三是调用isOnSyncQueue(node)方法判断结点是否在同步队列中，注意是个while循环，如果同步队列中没有该结点就直接挂起该线程，需要明白的是如果线程被唤醒后就调用acquireQueued(node, savedState)执行自旋操作争取锁，即当前线程结点从等待队列转移到同步队列并开始努力获取锁。</p>
<p>接着看看唤醒操作singal()方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public final void signal() &#123;</span><br><span class="line">    //判断是否持有独占锁，如果不是抛出异常</span><br><span class="line">  if (!isHeldExclusively())</span><br><span class="line">         throw new IllegalMonitorStateException();</span><br><span class="line">     Node first = firstWaiter;</span><br><span class="line">     //唤醒等待队列第一个结点的线程</span><br><span class="line">     if (first != null)</span><br><span class="line">         doSignal(first);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里signal()方法做了两件事，一是判断当前线程是否持有独占锁，没有就抛出异常，从这点也可以看出只有独占模式先采用等待队列，而共享模式下是没有等待队列的，也就没法使用Condition。二是唤醒等待队列的第一个结点，即执行doSignal(first)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">private void doSignal(Node first) &#123;</span><br><span class="line">     do &#123;</span><br><span class="line">             //移除条件等待队列中的第一个结点，</span><br><span class="line">             //如果后继结点为null，那么说没有其他结点将尾结点也设置为null</span><br><span class="line">            if ( (firstWaiter = first.nextWaiter) == null)</span><br><span class="line">                 lastWaiter = null;</span><br><span class="line">             first.nextWaiter = null;</span><br><span class="line">          //如果被通知节点没有进入到同步队列并且条件等待队列还有不为空的节点，则继续循环通知后续结点</span><br><span class="line">         &#125; while (!transferForSignal(first) &amp;&amp;</span><br><span class="line">                  (first = firstWaiter) != null);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">//transferForSignal方法</span><br><span class="line">final boolean transferForSignal(Node node) &#123;</span><br><span class="line">    //尝试设置唤醒结点的waitStatus为0，即初始化状态</span><br><span class="line">    //如果设置失败，说明当期结点node的waitStatus已不为</span><br><span class="line">    //CONDITION状态，那么只能是结束状态了，因此返回false</span><br><span class="line">    //返回doSignal()方法中继续唤醒其他结点的线程，注意这里并</span><br><span class="line">    //不涉及并发问题，所以CAS操作失败只可能是预期值不为CONDITION，</span><br><span class="line">    //而不是多线程设置导致预期值变化，毕竟操作该方法的线程是持有锁的。</span><br><span class="line">    if (!compareAndSetWaitStatus(node, Node.CONDITION, 0))</span><br><span class="line">         return false;</span><br><span class="line"></span><br><span class="line">        //加入同步队列并返回前驱结点p</span><br><span class="line">        Node p = enq(node);</span><br><span class="line">        int ws = p.waitStatus;</span><br><span class="line">        //判断前驱结点是否为结束结点(CANCELLED=1)或者在设置</span><br><span class="line">        //前驱节点状态为Node.SIGNAL状态失败时，唤醒被通知节点代表的线程</span><br><span class="line">        if (ws &gt; 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))</span><br><span class="line">            //唤醒node结点的线程</span><br><span class="line">            LockSupport.unpark(node.thread);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>注释说得很明白了，这里我们简单整体说明一下，doSignal(first)方法中做了两件事，从条件等待队列移除被唤醒的节点，然后重新维护条件等待队列的firstWaiter和lastWaiter的指向。二是将从等待队列移除的结点加入同步队列(在transferForSignal()方法中完成的)，如果进入到同步队列失败并且条件等待队列还有不为空的节点，则继续循环唤醒后续其他结点的线程。到此整个signal()的唤醒过程就很清晰了，即signal()被调用后，先判断当前线程是否持有独占锁，如果有，那么唤醒当前Condition对象中等待队列的第一个结点的线程，并从等待队列中移除该结点，移动到同步队列中，如果加入同步队列失败，那么继续循环唤醒等待队列中的其他结点的线程，如果成功加入同步队列，那么如果其前驱结点是否已结束或者设置前驱节点状态为Node.SIGNAL状态失败，则通过LockSupport.unpark()唤醒被通知节点代表的线程，到此signal()任务完成，注意被唤醒后的线程，将从前面的await()方法中的while循环中退出，因为此时该线程的结点已在同步队列中，那么while (!isOnSyncQueue(node))将不在符合循环条件，进而调用AQS的acquireQueued()方法加入获取同步状态的竞争中，这就是等待唤醒机制的整个流程实现原理，流程如下图所示（注意无论是同步队列还是等待队列使用的Node数据结构都是同一个，不过是使用的内部变量不同罢了）</p>
<p><img src="/images/pasted-74.png" alt="upload successful"></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://blog.csdn.net/javazejian/article/details/75043422" target="_blank" rel="noopener">http://blog.csdn.net/javazejian/article/details/75043422</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/02/28/java_thread/JUC-4-cas-unsafe/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Victor">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Victor的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/28/java_thread/JUC-4-cas-unsafe/" itemprop="url">CAS和Unsafe</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-28T09:03:00+08:00">
                2018-02-28
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/02/28/java_thread/JUC-4-cas-unsafe/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/02/28/java_thread/JUC-4-cas-unsafe/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2018/02/28/java_thread/JUC-4-cas-unsafe/" class="leancloud_visitors" data-flag-title="CAS和Unsafe">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="无锁的概念"><a href="#无锁的概念" class="headerlink" title="无锁的概念"></a>无锁的概念</h1><p>在谈论无锁概念时，总会关联起乐观派与悲观派，对于乐观派而言，他们认为事情总会往好的方向发展，总是认为坏的情况发生的概率特别小，可以无所顾忌地做事，但对于悲观派而已，他们总会认为发展事态如果不及时控制，以后就无法挽回了，即使无法挽回的局面几乎不可能发生。这两种派系映射到并发编程中就如同加锁与无锁的策略，即加锁是一种悲观策略，无锁是一种乐观策略，因为对于加锁的并发程序来说，它们总是认为每次访问共享资源时总会发生冲突，因此必须对每一次数据操作实施加锁策略。而无锁则总是假设对共享资源的访问没有冲突，线程可以不停执行，无需加锁，无需等待，一旦发现冲突，无锁策略则采用一种称为CAS的技术来保证线程执行的安全性，这项CAS技术就是无锁策略实现的关键，下面我们进一步了解CAS技术的奇妙之处。</p>
<h1 id="无锁的执行者-CAS"><a href="#无锁的执行者-CAS" class="headerlink" title="无锁的执行者-CAS"></a>无锁的执行者-CAS</h1><h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><p>CAS的全称是Compare And Swap 即比较交换，其算法核心思想如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">执行函数：CAS(V,E,N)</span><br></pre></td></tr></table></figure></p>
<p>如果V值等于E值，则将V的值设为N。若V值和E值不同，则说明已经有其他线程做了更新，则当前线程什么都不做。通俗的理解就是CAS操作需要我们提供一个期望值，当期望值与当前线程的变量值相同时，说明还没线程修改该值，当前线程可以进行修改，也就是执行CAS操作，但如果期望值与当前线程不符，则说明该值已被其他线程修改，此时不执行更新操作，但可以选择重新读取该变量再尝试再次修改该变量，也可以放弃操作</p>
<p>由于CAS操作属于乐观派，它总认为自己可以成功完成操作，当多个线程同时使用CAS操作一个变量时，只有一个会胜出，并成功更新，其余均会失败，但失败的线程并不会被挂起，仅是被告知失败，并且允许再次尝试，当然也允许失败的线程放弃操作。基于这样的原理，CAS操作即使没有锁，同样知道其他线程对共享资源操作影响，并执行相应的处理措施。同时从这点也可以看出，由于无锁操作中没有锁的存在，因此不可能出现死锁的情况，也就是说无锁操作天生免疫死锁。</p>
<h2 id="CPU指令对CAS的支持"><a href="#CPU指令对CAS的支持" class="headerlink" title="CPU指令对CAS的支持"></a>CPU指令对CAS的支持</h2><p>或许我们可能会有这样的疑问，假设存在多个线程执行CAS操作并且CAS的步骤很多，有没有可能在判断V和E相同后，正要赋值时，切换了线程，更改了值。造成了数据不一致呢？答案是否定的，因为CAS是一种系统原语，原语属于操作系统用语范畴，是由若干条指令组成的，用于完成某个功能的一个过程，并且原语的执行必须是连续的，在执行过程中不允许被中断，也就是说CAS是一条CPU的原子指令，不会造成所谓的数据不一致问题。</p>
<h1 id="鲜为人知的指针-Unsafe类"><a href="#鲜为人知的指针-Unsafe类" class="headerlink" title="鲜为人知的指针: Unsafe类"></a>鲜为人知的指针: Unsafe类</h1><p>Unsafe类存在于sun.misc包中，其内部方法操作可以像C的指针一样直接操作内存，单从名称看来就可以知道该类是非安全的，毕竟Unsafe拥有着类似于C的指针操作，因此总是不应该首先使用Unsafe类，Java官方也不建议直接使用的Unsafe类，据说Oracle正在计划从Java 9中去掉Unsafe类，但我们还是很有必要了解该类，因为Java中CAS操作的执行依赖于Unsafe类的方法，注意Unsafe类中的所有方法都是native修饰的，也就是说Unsafe类中的方法都直接调用操作系统底层资源执行相应任务，关于Unsafe类的主要功能点如下：</p>
<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><p>Unsafe类中存在直接操作内存的方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//分配内存指定大小的内存</span><br><span class="line">public native long allocateMemory(long bytes);</span><br><span class="line">//根据给定的内存地址address设置重新分配指定大小的内存</span><br><span class="line">public native long reallocateMemory(long address, long bytes);</span><br><span class="line">//用于释放allocateMemory和reallocateMemory申请的内存</span><br><span class="line">public native void freeMemory(long address);</span><br><span class="line">//将指定对象的给定offset偏移量内存块中的所有字节设置为固定值</span><br><span class="line">public native void setMemory(Object o, long offset, long bytes, byte value);</span><br><span class="line">//设置给定内存地址的值</span><br><span class="line">public native void putAddress(long address, long x);</span><br><span class="line">//获取指定内存地址的值</span><br><span class="line">public native long getAddress(long address);</span><br><span class="line"></span><br><span class="line">//设置给定内存地址的long值</span><br><span class="line">public native void putLong(long address, long x);</span><br><span class="line">//获取指定内存地址的long值</span><br><span class="line">public native long getLong(long address);</span><br><span class="line">//设置或获取指定内存的byte值</span><br><span class="line">public native byte  getByte(long address);</span><br><span class="line">public native void  putByte(long address, byte x);</span><br><span class="line">//其他基本数据类型(long,char,float,double,short等)的操作与putByte及getByte相同</span><br><span class="line"></span><br><span class="line">//操作系统的内存页大小</span><br><span class="line">public native int pageSize();</span><br></pre></td></tr></table></figure>
<h2 id="提供实例对象新途径"><a href="#提供实例对象新途径" class="headerlink" title="提供实例对象新途径"></a>提供实例对象新途径</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//传入一个对象的class并创建该实例对象，但不会调用构造方法</span><br><span class="line">public native Object allocateInstance(Class cls) throws InstantiationException;</span><br></pre></td></tr></table></figure>
<h2 id="类和实例对象以及变量的操作"><a href="#类和实例对象以及变量的操作" class="headerlink" title="类和实例对象以及变量的操作"></a>类和实例对象以及变量的操作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/获取字段f在实例对象中的偏移量</span><br><span class="line">public native long objectFieldOffset(Field f);</span><br><span class="line">//静态属性的偏移量，用于在对应的Class对象中读写静态属性</span><br><span class="line">public native long staticFieldOffset(Field f);</span><br><span class="line">//返回值就是f.getDeclaringClass()</span><br><span class="line">public native Object staticFieldBase(Field f);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//获得给定对象偏移量上的int值，所谓的偏移量可以简单理解为指针指向该变量的内存地址，</span><br><span class="line">//通过偏移量便可得到该对象的变量，进行各种操作</span><br><span class="line">public native int getInt(Object o, long offset);</span><br><span class="line">//设置给定对象上偏移量的int值</span><br><span class="line">public native void putInt(Object o, long offset, int x);</span><br><span class="line"></span><br><span class="line">//获得给定对象偏移量上的引用类型的值</span><br><span class="line">public native Object getObject(Object o, long offset);</span><br><span class="line">//设置给定对象偏移量上的引用类型的值</span><br><span class="line">public native void putObject(Object o, long offset, Object x);</span><br><span class="line">//其他基本数据类型(long,char,byte,float,double)的操作与getInthe及putInt相同</span><br><span class="line"></span><br><span class="line">//设置给定对象的int值，使用volatile语义，即设置后立马更新到内存对其他线程可见</span><br><span class="line">public native void  putIntVolatile(Object o, long offset, int x);</span><br><span class="line">//获得给定对象的指定偏移量offset的int值，使用volatile语义，总能获取到最新的int值。</span><br><span class="line">public native int getIntVolatile(Object o, long offset);</span><br><span class="line"></span><br><span class="line">//其他基本数据类型(long,char,byte,float,double)的操作与putIntVolatile及getIntVolatile相同，引用类型putObjectVolatile也一样。</span><br><span class="line"></span><br><span class="line">//与putIntVolatile一样，但要求被操作字段必须有volatile修饰</span><br><span class="line">public native void putOrderedInt(Object o,long offset,int x);</span><br></pre></td></tr></table></figure>
<p>下面通过一个简单的Demo来演示上述的一些方法以便加深对Unsafe类的理解</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">public class UnSafeDemo &#123;</span><br><span class="line"></span><br><span class="line">    public  static  void main(String[] args) throws NoSuchFieldException, IllegalAccessException, InstantiationException &#123;</span><br><span class="line">        // 通过反射得到theUnsafe对应的Field对象</span><br><span class="line">        Field field = Unsafe.class.getDeclaredField(&quot;theUnsafe&quot;);</span><br><span class="line">        // 设置该Field为可访问</span><br><span class="line">        field.setAccessible(true);</span><br><span class="line">        // 通过Field得到该Field对应的具体对象，传入null是因为该Field为static的</span><br><span class="line">        Unsafe unsafe = (Unsafe) field.get(null);</span><br><span class="line">        System.out.println(unsafe);</span><br><span class="line"></span><br><span class="line">        //通过allocateInstance直接创建对象</span><br><span class="line">        User user = (User) unsafe.allocateInstance(User.class);</span><br><span class="line"></span><br><span class="line">        Class userClass = user.getClass();</span><br><span class="line">        Field name = userClass.getDeclaredField(&quot;name&quot;);</span><br><span class="line">        Field age = userClass.getDeclaredField(&quot;age&quot;);</span><br><span class="line">        Field id = userClass.getDeclaredField(&quot;id&quot;);</span><br><span class="line"></span><br><span class="line">        //获取实例变量name和age在对象内存中的偏移量并设置值</span><br><span class="line">        unsafe.putInt(user,unsafe.objectFieldOffset(age),18);</span><br><span class="line">        unsafe.putObject(user,unsafe.objectFieldOffset(name),&quot;android TV&quot;);</span><br><span class="line"></span><br><span class="line">        // 这里返回 User.class，</span><br><span class="line">        Object staticBase = unsafe.staticFieldBase(id);</span><br><span class="line">        System.out.println(&quot;staticBase:&quot;+staticBase);</span><br><span class="line"></span><br><span class="line">        //获取静态变量id的偏移量staticOffset</span><br><span class="line">        long staticOffset = unsafe.staticFieldOffset(userClass.getDeclaredField(&quot;id&quot;));</span><br><span class="line">        //获取静态变量的值</span><br><span class="line">        System.out.println(&quot;设置前的ID:&quot;+unsafe.getObject(staticBase,staticOffset));</span><br><span class="line">        //设置值</span><br><span class="line">        unsafe.putObject(staticBase,staticOffset,&quot;SSSSSSSS&quot;);</span><br><span class="line">        //获取静态变量的值</span><br><span class="line">        System.out.println(&quot;设置前的ID:&quot;+unsafe.getObject(staticBase,staticOffset));</span><br><span class="line">        //输出USER</span><br><span class="line">        System.out.println(&quot;输出USER:&quot;+user.toString());</span><br><span class="line"></span><br><span class="line">        long data = 1000;</span><br><span class="line">        byte size = 1;//单位字节</span><br><span class="line"></span><br><span class="line">        //调用allocateMemory分配内存,并获取内存地址memoryAddress</span><br><span class="line">        long memoryAddress = unsafe.allocateMemory(size);</span><br><span class="line">        //直接往内存写入数据</span><br><span class="line">        unsafe.putAddress(memoryAddress, data);</span><br><span class="line">        //获取指定内存地址的数据</span><br><span class="line">        long addrData=unsafe.getAddress(memoryAddress);</span><br><span class="line">        System.out.println(&quot;addrData:&quot;+addrData);</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 输出结果:</span><br><span class="line">         sun.misc.Unsafe@6f94fa3e</span><br><span class="line">         staticBase:class geym.conc.ch4.atomic.User</span><br><span class="line">         设置前的ID:USER_ID</span><br><span class="line">         设置前的ID:SSSSSSSS</span><br><span class="line">         输出USER:User&#123;name=&apos;android TV&apos;, age=18&apos;, id=SSSSSSSS&apos;&#125;</span><br><span class="line">         addrData:1000</span><br><span class="line">         */</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class User&#123;</span><br><span class="line">    public User()&#123;</span><br><span class="line">        System.out.println(&quot;user 构造方法被调用&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">    private static String id=&quot;USER_ID&quot;;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;User&#123;&quot; +</span><br><span class="line">                &quot;name=&apos;&quot; + name + &apos;\&apos;&apos; +</span><br><span class="line">                &quot;, age=&quot; + age +&apos;\&apos;&apos; +</span><br><span class="line">                &quot;, id=&quot; + id +&apos;\&apos;&apos; +</span><br><span class="line">                &apos;&#125;&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static Unsafe getUnsafe() &#123;</span><br><span class="line">      Class cc = sun.reflect.Reflection.getCallerClass(2);</span><br><span class="line">      if (cc.getClassLoader() != null)</span><br><span class="line">          throw new SecurityException(&quot;Unsafe&quot;);</span><br><span class="line">      return theUnsafe;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>虽然在Unsafe类中存在getUnsafe()方法，但该方法只提供给高级的Bootstrap类加载器使用，普通用户调用将抛出异常，所以我们在Demo中使用了反射技术获取了Unsafe实例对象并进行相关操作。</p>
<h2 id="数组操作"><a href="#数组操作" class="headerlink" title="数组操作"></a>数组操作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//获取数组第一个元素的偏移地址</span><br><span class="line">public native int arrayBaseOffset(Class arrayClass);</span><br><span class="line">//数组中一个元素占据的内存空间,arrayBaseOffset与arrayIndexScale配合使用，可定位数组中每个元素在内存中的位置</span><br><span class="line">public native int arrayIndexScale(Class arrayClass);</span><br></pre></td></tr></table></figure>
<h2 id="CAS-操作相关"><a href="#CAS-操作相关" class="headerlink" title="CAS 操作相关"></a>CAS 操作相关</h2><p>CAS是一些CPU直接支持的指令，也就是我们前面分析的无锁操作，在Java中无锁操作CAS基于以下3个方法实现，在稍后讲解Atomic系列内部方法是基于下述方法的实现的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//第一个参数o为给定对象，offset为对象内存的偏移量，通过这个偏移量迅速定位字段并设置或获取该字段的值，</span><br><span class="line">//expected表示期望值，x表示要设置的值，下面3个方法都通过CAS原子指令执行操作。</span><br><span class="line">public final native boolean compareAndSwapObject(Object o, long offset,Object expected, Object x);                                                                                                  </span><br><span class="line"></span><br><span class="line">public final native boolean compareAndSwapInt(Object o, long offset,int expected,int x);</span><br><span class="line"></span><br><span class="line">public final native boolean compareAndSwapLong(Object o, long offset,long expected,long x);</span><br></pre></td></tr></table></figure></p>
<p>这里还需介绍Unsafe类中JDK 1.8新增的几个方法，它们的实现是基于上述的CAS方法，如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">//1.8新增，给定对象o，根据获取内存偏移量指向的字段，将其增加delta，</span><br><span class="line"> //这是一个CAS操作过程，直到设置成功方能退出循环，返回旧值</span><br><span class="line"> public final int getAndAddInt(Object o, long offset, int delta) &#123;</span><br><span class="line">     int v;</span><br><span class="line">     do &#123;</span><br><span class="line">         //获取内存中最新值</span><br><span class="line">         v = getIntVolatile(o, offset);</span><br><span class="line">       //通过CAS操作</span><br><span class="line">     &#125; while (!compareAndSwapInt(o, offset, v, v + delta));</span><br><span class="line">     return v;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">//1.8新增，方法作用同上，只不过这里操作的long类型数据</span><br><span class="line"> public final long getAndAddLong(Object o, long offset, long delta) &#123;</span><br><span class="line">     long v;</span><br><span class="line">     do &#123;</span><br><span class="line">         v = getLongVolatile(o, offset);</span><br><span class="line">     &#125; while (!compareAndSwapLong(o, offset, v, v + delta));</span><br><span class="line">     return v;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> //1.8新增，给定对象o，根据获取内存偏移量对于字段，将其 设置为新值newValue，</span><br><span class="line"> //这是一个CAS操作过程，直到设置成功方能退出循环，返回旧值</span><br><span class="line"> public final int getAndSetInt(Object o, long offset, int newValue) &#123;</span><br><span class="line">     int v;</span><br><span class="line">     do &#123;</span><br><span class="line">         v = getIntVolatile(o, offset);</span><br><span class="line">     &#125; while (!compareAndSwapInt(o, offset, v, newValue));</span><br><span class="line">     return v;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">// 1.8新增，同上，操作的是long类型</span><br><span class="line"> public final long getAndSetLong(Object o, long offset, long newValue) &#123;</span><br><span class="line">     long v;</span><br><span class="line">     do &#123;</span><br><span class="line">         v = getLongVolatile(o, offset);</span><br><span class="line">     &#125; while (!compareAndSwapLong(o, offset, v, newValue));</span><br><span class="line">     return v;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> //1.8新增，同上，操作的是引用类型数据</span><br><span class="line"> public final Object getAndSetObject(Object o, long offset, Object newValue) &#123;</span><br><span class="line">     Object v;</span><br><span class="line">     do &#123;</span><br><span class="line">         v = getObjectVolatile(o, offset);</span><br><span class="line">     &#125; while (!compareAndSwapObject(o, offset, v, newValue));</span><br><span class="line">     return v;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h2 id="挂起与恢复"><a href="#挂起与恢复" class="headerlink" title="挂起与恢复"></a>挂起与恢复</h2><p>将一个线程进行挂起是通过park方法实现的，调用 park后，线程将一直阻塞直到超时或者中断等条件出现。unpark可以终止一个挂起的线程，使其恢复正常。Java对线程的挂起操作被封装在 LockSupport类中，LockSupport类中有各种版本pack方法，其底层实现最终还是使用Unsafe.park()方法和Unsafe.unpark()方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//线程调用该方法，线程将一直阻塞直到超时，或者是中断条件出现。  </span><br><span class="line">public native void park(boolean isAbsolute, long time);  </span><br><span class="line"></span><br><span class="line">//终止挂起的线程，恢复正常.java.util.concurrent包中挂起操作都是在LockSupport类实现的，其底层正是使用这两个方法，  </span><br><span class="line">public native void unpark(Object thread);</span><br></pre></td></tr></table></figure>
<h2 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h2><p>这里主要包括了loadFence、storeFence、fullFence等方法，这些方法是在Java 8新引入的，用于定义内存屏障，避免代码重排序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//在该方法之前的所有读操作，一定在load屏障之前执行完成</span><br><span class="line">public native void loadFence();</span><br><span class="line">//在该方法之前的所有写操作，一定在store屏障之前执行完成</span><br><span class="line">public native void storeFence();</span><br><span class="line">//在该方法之前的所有读写操作，一定在full屏障之前执行完成，这个内存屏障相当于上面两个的合体功能</span><br><span class="line">public native void fullFence();</span><br></pre></td></tr></table></figure>
<h2 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//获取持有锁，已不建议使用</span><br><span class="line">@Deprecated</span><br><span class="line">public native void monitorEnter(Object var1);</span><br><span class="line">//释放锁，已不建议使用</span><br><span class="line">@Deprecated</span><br><span class="line">public native void monitorExit(Object var1);</span><br><span class="line">//尝试获取锁，已不建议使用</span><br><span class="line">@Deprecated</span><br><span class="line">public native boolean tryMonitorEnter(Object var1);</span><br><span class="line"></span><br><span class="line">//获取本机内存的页数，这个值永远都是2的幂次方  </span><br><span class="line">public native int pageSize();  </span><br><span class="line"></span><br><span class="line">//告诉虚拟机定义了一个没有安全检查的类，默认情况下这个类加载器和保护域来着调用者类  </span><br><span class="line">public native Class defineClass(String name, byte[] b, int off, int len, ClassLoader loader, ProtectionDomain protectionDomain);  </span><br><span class="line"></span><br><span class="line">//加载一个匿名类</span><br><span class="line">public native Class defineAnonymousClass(Class hostClass, byte[] data, Object[] cpPatches);</span><br><span class="line">//判断是否需要加载一个类</span><br><span class="line">public native boolean shouldBeInitialized(Class&lt;?&gt; c);</span><br><span class="line">//确保类一定被加载</span><br><span class="line">public native  void ensureClassInitialized(Class&lt;?&gt; c)</span><br></pre></td></tr></table></figure>
<h1 id="并发包中的原子操作类-Atomic系列"><a href="#并发包中的原子操作类-Atomic系列" class="headerlink" title="并发包中的原子操作类(Atomic系列)"></a>并发包中的原子操作类(Atomic系列)</h1><p>通过前面的分析我们已基本理解了无锁CAS的原理并对Java中的指针类Unsafe类有了比较全面的认识，下面进一步分析CAS在Java中的应用，即并发包中的原子操作类(Atomic系列)，从JDK 1.5开始提供了java.util.concurrent.atomic包，在该包中提供了许多基于CAS实现的原子操作类，用法方便，性能高效，主要分以下4种类型。</p>
<h2 id="原子更新基本类型"><a href="#原子更新基本类型" class="headerlink" title="原子更新基本类型"></a>原子更新基本类型</h2><p>原子更新基本类型主要包括3个类：</p>
<p>AtomicBoolean：原子更新布尔类型<br>AtomicInteger：原子更新整型<br>AtomicLong：原子更新长整型<br>这3个类的实现原理和使用方式几乎是一样的，这里我们以AtomicInteger为例进行分析，AtomicInteger主要是针对int类型的数据执行原子操作，它提供了原子自增方法、原子自减方法以及原子赋值方法等，鉴于AtomicInteger的源码不多，我们直接看源码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">public class AtomicInteger extends Number implements java.io.Serializable &#123;</span><br><span class="line">    private static final long serialVersionUID = 6214790243416807050L;</span><br><span class="line"></span><br><span class="line">    // 获取指针类Unsafe</span><br><span class="line">    private static final Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line"></span><br><span class="line">    //下述变量value在AtomicInteger实例对象内的内存偏移量</span><br><span class="line">    private static final long valueOffset;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">           //通过unsafe类的objectFieldOffset()方法，获取value变量在对象内存中的偏移</span><br><span class="line">           //通过该偏移量valueOffset，unsafe类的内部方法可以获取到变量value对其进行取值或赋值操作</span><br><span class="line">            valueOffset = unsafe.objectFieldOffset</span><br><span class="line">                (AtomicInteger.class.getDeclaredField(&quot;value&quot;));</span><br><span class="line">        &#125; catch (Exception ex) &#123; throw new Error(ex); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   //当前AtomicInteger封装的int变量value</span><br><span class="line">    private volatile int value;</span><br><span class="line"></span><br><span class="line">    public AtomicInteger(int initialValue) &#123;</span><br><span class="line">        value = initialValue;</span><br><span class="line">    &#125;</span><br><span class="line">    public AtomicInteger() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">   //获取当前最新值，</span><br><span class="line">    public final int get() &#123;</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line">    //设置当前值，具备volatile效果，方法用final修饰是为了更进一步的保证线程安全。</span><br><span class="line">    public final void set(int newValue) &#123;</span><br><span class="line">        value = newValue;</span><br><span class="line">    &#125;</span><br><span class="line">    //最终会设置成newValue，使用该方法后可能导致其他线程在之后的一小段时间内可以获取到旧值，有点类似于延迟加载</span><br><span class="line">    public final void lazySet(int newValue) &#123;</span><br><span class="line">        unsafe.putOrderedInt(this, valueOffset, newValue);</span><br><span class="line">    &#125;</span><br><span class="line">   //设置新值并获取旧值，底层调用的是CAS操作即unsafe.compareAndSwapInt()方法</span><br><span class="line">    public final int getAndSet(int newValue) &#123;</span><br><span class="line">        return unsafe.getAndSetInt(this, valueOffset, newValue);</span><br><span class="line">    &#125;</span><br><span class="line">   //如果当前值为expect，则设置为update(当前值指的是value变量)</span><br><span class="line">    public final boolean compareAndSet(int expect, int update) &#123;</span><br><span class="line">        return unsafe.compareAndSwapInt(this, valueOffset, expect, update);</span><br><span class="line">    &#125;</span><br><span class="line">    //当前值加1返回旧值，底层CAS操作</span><br><span class="line">    public final int getAndIncrement() &#123;</span><br><span class="line">        return unsafe.getAndAddInt(this, valueOffset, 1);</span><br><span class="line">    &#125;</span><br><span class="line">    //当前值减1，返回旧值，底层CAS操作</span><br><span class="line">    public final int getAndDecrement() &#123;</span><br><span class="line">        return unsafe.getAndAddInt(this, valueOffset, -1);</span><br><span class="line">    &#125;</span><br><span class="line">   //当前值增加delta，返回旧值，底层CAS操作</span><br><span class="line">    public final int getAndAdd(int delta) &#123;</span><br><span class="line">        return unsafe.getAndAddInt(this, valueOffset, delta);</span><br><span class="line">    &#125;</span><br><span class="line">    //当前值加1，返回新值，底层CAS操作</span><br><span class="line">    public final int incrementAndGet() &#123;</span><br><span class="line">        return unsafe.getAndAddInt(this, valueOffset, 1) + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    //当前值减1，返回新值，底层CAS操作</span><br><span class="line">    public final int decrementAndGet() &#123;</span><br><span class="line">        return unsafe.getAndAddInt(this, valueOffset, -1) - 1;</span><br><span class="line">    &#125;</span><br><span class="line">   //当前值增加delta，返回新值，底层CAS操作</span><br><span class="line">    public final int addAndGet(int delta) &#123;</span><br><span class="line">        return unsafe.getAndAddInt(this, valueOffset, delta) + delta;</span><br><span class="line">    &#125;</span><br><span class="line">   //省略一些不常用的方法....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过上述的分析，可以发现AtomicInteger原子类的内部几乎是基于前面分析过Unsafe类中的CAS相关操作的方法实现的，这也同时证明AtomicInteger是基于无锁实现的，这里重点分析自增操作实现过程，其他方法自增实现原理一样。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//当前值加1，返回新值，底层CAS操作</span><br><span class="line">public final int incrementAndGet() &#123;</span><br><span class="line">     return unsafe.getAndAddInt(this, valueOffset, 1) + 1;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>我们发现AtomicInteger类中所有自增或自减的方法都间接调用Unsafe类中的getAndAddInt()方法实现了CAS操作，从而保证了线程安全，关于getAndAddInt其实前面已分析过，它是Unsafe类中1.8新增的方法，源码如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//Unsafe类中的getAndAddInt方法</span><br><span class="line">public final int getAndAddInt(Object o, long offset, int delta) &#123;</span><br><span class="line">        int v;</span><br><span class="line">        do &#123;</span><br><span class="line">            v = getIntVolatile(o, offset);</span><br><span class="line">        &#125; while (!compareAndSwapInt(o, offset, v, v + delta));</span><br><span class="line">        return v;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可看出getAndAddInt通过一个while循环不断的重试更新要设置的值，直到成功为止，调用的是Unsafe类中的compareAndSwapInt方法，是一个CAS操作方法。这里需要注意的是，上述源码分析是基于JDK1.8的，如果是1.8之前的方法，AtomicInteger源码实现有所不同，是基于for死循环的，如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//JDK 1.7的源码，由for的死循环实现，并且直接在AtomicInteger实现该方法，</span><br><span class="line">//JDK1.8后，该方法实现已移动到Unsafe类中，直接调用getAndAddInt方法即可</span><br><span class="line">public final int incrementAndGet() &#123;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        int current = get();</span><br><span class="line">        int next = current + 1;</span><br><span class="line">        if (compareAndSet(current, next))</span><br><span class="line">            return next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="原子更新引用"><a href="#原子更新引用" class="headerlink" title="原子更新引用"></a>原子更新引用</h2><p>原子更新引用类型可以同时更新引用类型，这里主要分析一下AtomicReference原子类，即原子更新引用类型。先看看其使用方式，如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public class AtomicReferenceDemo2 &#123;</span><br><span class="line"></span><br><span class="line">    public static AtomicReference&lt;User&gt; atomicUserRef = new AtomicReference&lt;User&gt;();</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        User user = new User(&quot;zejian&quot;, 18);</span><br><span class="line">        atomicUserRef.set(user);</span><br><span class="line">        User updateUser = new User(&quot;Shine&quot;, 25);</span><br><span class="line">        atomicUserRef.compareAndSet(user, updateUser);</span><br><span class="line">        //执行结果:User&#123;name=&apos;Shine&apos;, age=25&#125;</span><br><span class="line">              System.out.println(atomicUserRef.get().toString());  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class User &#123;</span><br><span class="line">        public String name;</span><br><span class="line">        private int age;</span><br><span class="line"></span><br><span class="line">        public User(String name, int age) &#123;</span><br><span class="line">            this.name = name;</span><br><span class="line">            this.age = age;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public String getName() &#123;</span><br><span class="line">            return name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public String toString() &#123;</span><br><span class="line">            return &quot;User&#123;&quot; +</span><br><span class="line">                    &quot;name=&apos;&quot; + name + &apos;\&apos;&apos; +</span><br><span class="line">                    &quot;, age=&quot; + age +</span><br><span class="line">                    &apos;&#125;&apos;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么AtomicReference原子类内部是如何实现CAS操作的呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public class AtomicReference&lt;V&gt; implements java.io.Serializable &#123;</span><br><span class="line">    private static final Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line">    private static final long valueOffset;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            valueOffset = unsafe.objectFieldOffset</span><br><span class="line">                (AtomicReference.class.getDeclaredField(&quot;value&quot;));</span><br><span class="line">        &#125; catch (Exception ex) &#123; throw new Error(ex); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //内部变量value，Unsafe类通过valueOffset内存偏移量即可获取该变量</span><br><span class="line">    private volatile V value;</span><br><span class="line"></span><br><span class="line">//CAS方法，间接调用unsafe.compareAndSwapObject(),它是一个</span><br><span class="line">//实现了CAS操作的native方法</span><br><span class="line">public final boolean compareAndSet(V expect, V update) &#123;</span><br><span class="line">        return unsafe.compareAndSwapObject(this, valueOffset, expect, update);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//设置并获取旧值</span><br><span class="line">public final V getAndSet(V newValue) &#123;</span><br><span class="line">        return (V)unsafe.getAndSetObject(this, valueOffset, newValue);</span><br><span class="line">    &#125;</span><br><span class="line">    //省略其他代码......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//Unsafe类中的getAndSetObject方法，实际调用还是CAS操作</span><br><span class="line">public final Object getAndSetObject(Object o, long offset, Object newValue) &#123;</span><br><span class="line">      Object v;</span><br><span class="line">      do &#123;</span><br><span class="line">          v = getObjectVolatile(o, offset);</span><br><span class="line">      &#125; while (!compareAndSwapObject(o, offset, v, newValue));</span><br><span class="line">      return v;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h2 id="原子更新数组"><a href="#原子更新数组" class="headerlink" title="原子更新数组"></a>原子更新数组</h2><p>原子更新数组指的是通过原子的方式更新数组里的某个元素，主要有以下3个类</p>
<p>AtomicIntegerArray：原子更新整数数组里的元素<br>AtomicLongArray：原子更新长整数数组里的元素<br>AtomicReferenceArray：原子更新引用类型数组里的元素<br>这里以AtomicIntegerArray为例进行分析，其余两个使用方式和实现原理基本一样，简单案例如下，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class AtomicIntegerArrayDemo &#123;</span><br><span class="line">    static AtomicIntegerArray arr = new AtomicIntegerArray(10);</span><br><span class="line"></span><br><span class="line">    public static class AddThread implements Runnable&#123;</span><br><span class="line">        public void run()&#123;</span><br><span class="line">           for(int k=0;k&lt;10000;k++)</span><br><span class="line">               //执行数组中元素自增操作,参数为index,即数组下标</span><br><span class="line">               arr.getAndIncrement(k%arr.length());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        Thread[] ts=new Thread[10];</span><br><span class="line">        //创建10条线程</span><br><span class="line">        for(int k=0;k&lt;10;k++)&#123;</span><br><span class="line">            ts[k]=new Thread(new AddThread());</span><br><span class="line">        &#125;</span><br><span class="line">        //启动10条线程</span><br><span class="line">        for(int k=0;k&lt;10;k++)&#123;ts[k].start();&#125;</span><br><span class="line">        for(int k=0;k&lt;10;k++)&#123;ts[k].join();&#125;</span><br><span class="line">        //执行结果</span><br><span class="line">        //[10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000]</span><br><span class="line">        System.out.println(arr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>启动10条线程对数组中的元素进行自增操作，执行结果符合预期。使用方式比较简单，接着看看AtomicIntegerArray内部是如何实现，先看看部分源码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public class AtomicIntegerArray implements java.io.Serializable &#123;</span><br><span class="line">    //获取unsafe类的实例对象</span><br><span class="line">    private static final Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line">    //获取数组的第一个元素内存起始地址</span><br><span class="line">    private static final int base = unsafe.arrayBaseOffset(int[].class);</span><br><span class="line"></span><br><span class="line">    private static final int shift;</span><br><span class="line">    //内部数组</span><br><span class="line">    private final int[] array;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        //获取数组中一个元素占据的内存空间</span><br><span class="line">        int scale = unsafe.arrayIndexScale(int[].class);</span><br><span class="line">        //判断是否为2的次幂，一般为2的次幂否则抛异常</span><br><span class="line">        if ((scale &amp; (scale - 1)) != 0)</span><br><span class="line">            throw new Error(&quot;data type scale not a power of two&quot;);</span><br><span class="line">        //</span><br><span class="line">        shift = 31 - Integer.numberOfLeadingZeros(scale);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private long checkedByteOffset(int i) &#123;</span><br><span class="line">        if (i &lt; 0 || i &gt;= array.length)</span><br><span class="line">            throw new IndexOutOfBoundsException(&quot;index &quot; + i);</span><br><span class="line"></span><br><span class="line">        return byteOffset(i);</span><br><span class="line">    &#125;</span><br><span class="line">    //计算数组中每个元素的的内存地址</span><br><span class="line">    private static long byteOffset(int i) &#123;</span><br><span class="line">        return ((long) i &lt;&lt; shift) + base;</span><br><span class="line">    &#125;</span><br><span class="line">    //省略其他代码......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过前面对Unsafe类的分析，我们知道arrayBaseOffset方法可以获取数组的第一个元素起始地址，而arrayIndexScale方法可以获取每个数组元素占用的内存空间，由于这里是Int类型，而Java中一个int类型占用4个字节，也就是scale的值为4，那么如何根据数组下标值计算每个元素的内存地址呢？显然应该是<br><code>每个数组元素的内存地址=起始地址+元素下标 * 每个元素所占用的内存空间</code></p>
<h2 id="原子更新属性"><a href="#原子更新属性" class="headerlink" title="原子更新属性"></a>原子更新属性</h2><p>如果我们只需要某个类里的某个字段，也就是说让普通的变量也享受原子操作，可以使用原子更新字段类，如在某些时候由于项目前期考虑不周全，项目需求又发生变化，使得某个类中的变量需要执行多线程操作，由于该变量多处使用，改动起来比较麻烦，而且原来使用的地方无需使用线程安全，只要求新场景需要使用时，可以借助原子更新器处理这种场景，Atomic并发包提供了以下三个类：</p>
<p>AtomicIntegerFieldUpdater：原子更新整型的字段的更新器。<br>AtomicLongFieldUpdater：原子更新长整型字段的更新器。<br>AtomicReferenceFieldUpdater：原子更新引用类型里的字段。<br>请注意原子更新器的使用存在比较苛刻的条件如下</p>
<p>操作的字段不能是static类型。</p>
<p>操作的字段不能是final类型的，因为final根本没法修改。</p>
<p>字段必须是volatile修饰的，也就是数据本身是读一致的。</p>
<p>属性必须对当前的Updater所在的区域是可见的，如果不是当前类内部进行原子更新器操作不能使用private，protected子类操作父类时修饰符必须是protect权限及以上，如果在同一个package下则必须是default权限及以上，也就是说无论何时都应该保证操作类与被操作类间的可见性。</p>
<p>下面看看AtomicIntegerFieldUpdater和AtomicReferenceFieldUpdater的简单使用方式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">public class AtomicIntegerFieldUpdaterDemo &#123;</span><br><span class="line">    public static class Candidate&#123;</span><br><span class="line">        int id;</span><br><span class="line">        volatile int score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class Game&#123;</span><br><span class="line">        int id;</span><br><span class="line">        volatile String name;</span><br><span class="line"></span><br><span class="line">        public Game(int id, String name) &#123;</span><br><span class="line">            this.id = id;</span><br><span class="line">            this.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public String toString() &#123;</span><br><span class="line">            return &quot;Game&#123;&quot; +</span><br><span class="line">                    &quot;id=&quot; + id +</span><br><span class="line">                    &quot;, name=&apos;&quot; + name + &apos;\&apos;&apos; +</span><br><span class="line">                    &apos;&#125;&apos;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static AtomicIntegerFieldUpdater&lt;Candidate&gt; atIntegerUpdater</span><br><span class="line">        = AtomicIntegerFieldUpdater.newUpdater(Candidate.class, &quot;score&quot;);</span><br><span class="line"></span><br><span class="line">    static AtomicReferenceFieldUpdater&lt;Game,String&gt; atRefUpdate =</span><br><span class="line">            AtomicReferenceFieldUpdater.newUpdater(Game.class,String.class,&quot;name&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //用于验证分数是否正确</span><br><span class="line">    public static AtomicInteger allScore=new AtomicInteger(0);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        final Candidate stu=new Candidate();</span><br><span class="line">        Thread[] t=new Thread[10000];</span><br><span class="line">        //开启10000个线程</span><br><span class="line">        for(int i = 0 ; i &lt; 10000 ; i++) &#123;</span><br><span class="line">            t[i]=new Thread() &#123;</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    if(Math.random()&gt;0.4)&#123;</span><br><span class="line">                        atIntegerUpdater.incrementAndGet(stu);</span><br><span class="line">                        allScore.incrementAndGet();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            t[i].start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for(int i = 0 ; i &lt; 10000 ; i++) &#123;  t[i].join();&#125;</span><br><span class="line">        System.out.println(&quot;最终分数score=&quot;+stu.score);</span><br><span class="line">        System.out.println(&quot;校验分数allScore=&quot;+allScore);</span><br><span class="line"></span><br><span class="line">        //AtomicReferenceFieldUpdater 简单的使用</span><br><span class="line">        Game game = new Game(2,&quot;zh&quot;);</span><br><span class="line">        atRefUpdate.compareAndSet(game,game.name,&quot;JAVA-HHH&quot;);</span><br><span class="line">        System.out.println(game.toString());</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 输出结果:</span><br><span class="line">         * 最终分数score=5976</span><br><span class="line">           校验分数allScore=5976</span><br><span class="line">           Game&#123;id=2, name=&apos;JAVA-HHH&apos;&#125;</span><br><span class="line">         */</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们使用AtomicIntegerFieldUpdater更新候选人(Candidate)的分数score，开启了10000条线程投票，当随机值大于0.4时算一票，分数自增一次，其中allScore用于验证分数是否正确(其实用于验证AtomicIntegerFieldUpdater更新的字段是否线程安全)，当allScore与score相同时，则说明投票结果无误，也代表AtomicIntegerFieldUpdater能正确更新字段score的值，是线程安全的。对于AtomicReferenceFieldUpdater，我们在代码中简单演示了其使用方式，注意在AtomicReferenceFieldUpdater注明泛型时需要两个泛型参数，一个是修改的类类型，一个修改字段的类型。至于AtomicLongFieldUpdater则与AtomicIntegerFieldUpdater类似，不再介绍。接着简单了解一下AtomicIntegerFieldUpdater的实现原理，实际就是反射和Unsafe类结合，AtomicIntegerFieldUpdater是个抽象类，实际实现类为AtomicIntegerFieldUpdaterImpl</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AtomicIntegerFieldUpdater&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    public static &lt;U&gt; AtomicIntegerFieldUpdater&lt;U&gt; newUpdater(Class&lt;U&gt; tclass,</span><br><span class="line">                                                              String fieldName) &#123;</span><br><span class="line">         //实际实现类AtomicIntegerFieldUpdaterImpl                                          </span><br><span class="line">        return new AtomicIntegerFieldUpdaterImpl&lt;U&gt;</span><br><span class="line">            (tclass, fieldName, Reflection.getCallerClass());</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>看看AtomicIntegerFieldUpdaterImpl</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">private static class AtomicIntegerFieldUpdaterImpl&lt;T&gt;</span><br><span class="line">            extends AtomicIntegerFieldUpdater&lt;T&gt; &#123;</span><br><span class="line">        private static final Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line">        private final long offset;//内存偏移量</span><br><span class="line">        private final Class&lt;T&gt; tclass;</span><br><span class="line">        private final Class&lt;?&gt; cclass;</span><br><span class="line"></span><br><span class="line">        AtomicIntegerFieldUpdaterImpl(final Class&lt;T&gt; tclass,</span><br><span class="line">                                      final String fieldName,</span><br><span class="line">                                      final Class&lt;?&gt; caller) &#123;</span><br><span class="line">            final Field field;//要修改的字段</span><br><span class="line">            final int modifiers;//字段修饰符</span><br><span class="line">            try &#123;</span><br><span class="line">                field = AccessController.doPrivileged(</span><br><span class="line">                    new PrivilegedExceptionAction&lt;Field&gt;() &#123;</span><br><span class="line">                        public Field run() throws NoSuchFieldException &#123;</span><br><span class="line">                            return tclass.getDeclaredField(fieldName);//反射获取字段对象</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                    //获取字段修饰符</span><br><span class="line">                modifiers = field.getModifiers();</span><br><span class="line">            //对字段的访问权限进行检查,不在访问范围内抛异常</span><br><span class="line">                sun.reflect.misc.ReflectUtil.ensureMemberAccess(</span><br><span class="line">                    caller, tclass, null, modifiers);</span><br><span class="line">                ClassLoader cl = tclass.getClassLoader();</span><br><span class="line">                ClassLoader ccl = caller.getClassLoader();</span><br><span class="line">                if ((ccl != null) &amp;&amp; (ccl != cl) &amp;&amp;</span><br><span class="line">                    ((cl == null) || !isAncestor(cl, ccl))) &#123;</span><br><span class="line">              sun.reflect.misc.ReflectUtil.checkPackageAccess(tclass);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (PrivilegedActionException pae) &#123;</span><br><span class="line">                throw new RuntimeException(pae.getException());</span><br><span class="line">            &#125; catch (Exception ex) &#123;</span><br><span class="line">                throw new RuntimeException(ex);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Class&lt;?&gt; fieldt = field.getType();</span><br><span class="line">            //判断是否为int类型</span><br><span class="line">            if (fieldt != int.class)</span><br><span class="line">                throw new IllegalArgumentException(&quot;Must be integer type&quot;);</span><br><span class="line">            //判断是否被volatile修饰</span><br><span class="line">            if (!Modifier.isVolatile(modifiers))</span><br><span class="line">                throw new IllegalArgumentException(&quot;Must be volatile type&quot;);</span><br><span class="line"></span><br><span class="line">            this.cclass = (Modifier.isProtected(modifiers) &amp;&amp;</span><br><span class="line">                           caller != tclass) ? caller : null;</span><br><span class="line">            this.tclass = tclass;</span><br><span class="line">            //获取该字段的在对象内存的偏移量，通过内存偏移量可以获取或者修改该字段的值</span><br><span class="line">            offset = unsafe.objectFieldOffset(field);</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>从AtomicIntegerFieldUpdaterImpl的构造器也可以看出更新器为什么会有这么多限制条件了，当然最终其CAS操作肯定是通过unsafe完成的，简单看一个方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public int incrementAndGet(T obj) &#123;</span><br><span class="line">        int prev, next;</span><br><span class="line">        do &#123;</span><br><span class="line">            prev = get(obj);</span><br><span class="line">            next = prev + 1;</span><br><span class="line">            //CAS操作</span><br><span class="line">        &#125; while (!compareAndSet(obj, prev, next));</span><br><span class="line">        return next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//最终调用的还是unsafe.compareAndSwapInt()方法</span><br><span class="line">public boolean compareAndSet(T obj, int expect, int update) &#123;</span><br><span class="line">            if (obj == null || obj.getClass() != tclass || cclass != null) fullCheck(obj);</span><br><span class="line">            return unsafe.compareAndSwapInt(obj, offset, expect, update);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="CAS的ABA问题及其解决方案"><a href="#CAS的ABA问题及其解决方案" class="headerlink" title="CAS的ABA问题及其解决方案"></a>CAS的ABA问题及其解决方案</h1><p>假设这样一种场景，当第一个线程执行CAS(V,E,U)操作，在获取到当前变量V，准备修改为新值U前，另外两个线程已连续修改了两次变量V的值，使得该值又恢复为旧值，这样的话，我们就无法正确判断这个变量是否已被修改过，如下图</p>
<p><img src="/images/pasted-65.png" alt="upload successful"></p>
<p>这就是典型的CAS的ABA问题，一般情况这种情况发现的概率比较小，可能发生了也不会造成什么问题，比如说我们对某个做加减法，不关心数字的过程，那么发生ABA问题也没啥关系。但是在某些情况下还是需要防止的，那么该如何解决呢？在Java中解决ABA问题，我们可以使用以下两个原子类</p>
<p>AtomicStampedReference</p>
<p>AtomicStampedReference原子类是一个带有时间戳的对象引用，在每次修改后，AtomicStampedReference不仅会设置新值而且还会记录更改的时间。当AtomicStampedReference设置对象值时，对象值以及时间戳都必须满足期望值才能写入成功，这也就解决了反复读写时，无法预知值是否已被修改的窘境，测试demo如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Created by zejian on 2017/7/2.</span><br><span class="line"> * Blog : http://blog.csdn.net/javazejian [原文地址,请尊重原创]</span><br><span class="line"> */</span><br><span class="line">public class ABADemo &#123;</span><br><span class="line"></span><br><span class="line">    static AtomicInteger atIn = new AtomicInteger(100);</span><br><span class="line"></span><br><span class="line">    //初始化时需要传入一个初始值和初始时间</span><br><span class="line">    static AtomicStampedReference&lt;Integer&gt; atomicStampedR =</span><br><span class="line">            new AtomicStampedReference&lt;Integer&gt;(200,0);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    static Thread t1 = new Thread(new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            //更新为200</span><br><span class="line">            atIn.compareAndSet(100, 200);</span><br><span class="line">            //更新为100</span><br><span class="line">            atIn.compareAndSet(200, 100);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    static Thread t2 = new Thread(new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(1);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            boolean flag=atIn.compareAndSet(100,500);</span><br><span class="line">            System.out.println(&quot;flag:&quot;+flag+&quot;,newValue:&quot;+atIn);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    static Thread t3 = new Thread(new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            int time=atomicStampedR.getStamp();</span><br><span class="line">            //更新为200</span><br><span class="line">            atomicStampedR.compareAndSet(100, 200,time,time+1);</span><br><span class="line">            //更新为100</span><br><span class="line">            int time2=atomicStampedR.getStamp();</span><br><span class="line">            atomicStampedR.compareAndSet(200, 100,time2,time2+1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    static Thread t4 = new Thread(new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            int time = atomicStampedR.getStamp();</span><br><span class="line">            System.out.println(&quot;sleep 前 t4 time:&quot;+time);</span><br><span class="line">            try &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(1);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            boolean flag=atomicStampedR.compareAndSet(100,500,time,time+1);</span><br><span class="line">            System.out.println(&quot;flag:&quot;+flag+&quot;,newValue:&quot;+atomicStampedR.getReference());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    public static  void  main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line"></span><br><span class="line">        t3.start();</span><br><span class="line">        t4.start();</span><br><span class="line">        /**</span><br><span class="line">         * 输出结果:</span><br><span class="line">         flag:true,newValue:500</span><br><span class="line">         sleep 前 t4 time:0</span><br><span class="line">         flag:false,newValue:200</span><br><span class="line">         */</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对比输出结果可知，AtomicStampedReference类确实解决了ABA的问题，下面我们简单看看其内部实现原理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class AtomicStampedReference&lt;V&gt; &#123;</span><br><span class="line">    //通过Pair内部类存储数据和时间戳</span><br><span class="line">    private static class Pair&lt;T&gt; &#123;</span><br><span class="line">        final T reference;</span><br><span class="line">        final int stamp;</span><br><span class="line">        private Pair(T reference, int stamp) &#123;</span><br><span class="line">            this.reference = reference;</span><br><span class="line">            this.stamp = stamp;</span><br><span class="line">        &#125;</span><br><span class="line">        static &lt;T&gt; Pair&lt;T&gt; of(T reference, int stamp) &#123;</span><br><span class="line">            return new Pair&lt;T&gt;(reference, stamp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //存储数值和时间的内部类</span><br><span class="line">    private volatile Pair&lt;V&gt; pair;</span><br><span class="line"></span><br><span class="line">    //构造器，创建时需传入初始值和时间初始值</span><br><span class="line">    public AtomicStampedReference(V initialRef, int initialStamp) &#123;</span><br><span class="line">        pair = Pair.of(initialRef, initialStamp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着看看其compareAndSet方法的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public boolean compareAndSet(V   expectedReference,</span><br><span class="line">                                 V   newReference,</span><br><span class="line">                                 int expectedStamp,</span><br><span class="line">                                 int newStamp) &#123;</span><br><span class="line">        Pair&lt;V&gt; current = pair;</span><br><span class="line">        return</span><br><span class="line">            expectedReference == current.reference &amp;&amp;</span><br><span class="line">            expectedStamp == current.stamp &amp;&amp;</span><br><span class="line">            ((newReference == current.reference &amp;&amp;</span><br><span class="line">              newStamp == current.stamp) ||</span><br><span class="line">             casPair(current, Pair.of(newReference, newStamp)));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>同时对当前数据和当前时间进行比较，只有两者都相等是才会执行casPair()方法，单从该方法的名称就可知是一个CAS方法，最终调用的还是Unsafe类中的compareAndSwapObject方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private boolean casPair(Pair&lt;V&gt; cmp, Pair&lt;V&gt; val) &#123;</span><br><span class="line">        return UNSAFE.compareAndSwapObject(this, pairOffset, cmp, val);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>到这我们就很清晰AtomicStampedReference的内部实现思想了，通过一个键值对Pair存储数据和时间戳，在更新时对数据和时间戳进行比较，只有两者都符合预期才会调用Unsafe的compareAndSwapObject方法执行数值和时间戳替换，也就避免了ABA的问题。</p>
<p>AtomicMarkableReference类</p>
<p>AtomicMarkableReference与AtomicStampedReference不同的是，AtomicMarkableReference维护的是一个boolean值的标识，也就是说至于true和false两种切换状态，经过博主测试，这种方式并不能完全防止ABA问题的发生，只能减少ABA问题发生的概率。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">public class ABADemo &#123;</span><br><span class="line">    static AtomicMarkableReference&lt;Integer&gt; atMarkRef =</span><br><span class="line">              new AtomicMarkableReference&lt;Integer&gt;(100,false);</span><br><span class="line"></span><br><span class="line"> static Thread t5 = new Thread(new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            boolean mark=atMarkRef.isMarked();</span><br><span class="line">            System.out.println(&quot;mark:&quot;+mark);</span><br><span class="line">            //更新为200</span><br><span class="line">            System.out.println(&quot;t5 result:&quot;+atMarkRef.compareAndSet(atMarkRef.getReference(), 200,mark,!mark));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    static Thread t6 = new Thread(new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            boolean mark2=atMarkRef.isMarked();</span><br><span class="line">            System.out.println(&quot;mark2:&quot;+mark2);</span><br><span class="line">            System.out.println(&quot;t6 result:&quot;+atMarkRef.compareAndSet(atMarkRef.getReference(), 100,mark2,!mark2));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    static Thread t7 = new Thread(new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            boolean mark=atMarkRef.isMarked();</span><br><span class="line">            System.out.println(&quot;sleep 前 t7 mark:&quot;+mark);</span><br><span class="line">            try &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(1);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            boolean flag=atMarkRef.compareAndSet(100,500,mark,!mark);</span><br><span class="line">            System.out.println(&quot;flag:&quot;+flag+&quot;,newValue:&quot;+atMarkRef.getReference());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    public static  void  main(String[] args) throws InterruptedException &#123;        </span><br><span class="line">        t5.start();t5.join();</span><br><span class="line">        t6.start();t6.join();</span><br><span class="line">        t7.start();</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 输出结果:</span><br><span class="line">         mark:false</span><br><span class="line">         t5 result:true</span><br><span class="line">         mark2:true</span><br><span class="line">         t6 result:true</span><br><span class="line">         sleep 前 t5 mark:false</span><br><span class="line">         flag:true,newValue:500 ----&gt;成功了.....说明还是发生ABA问题</span><br><span class="line">         */</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="再谈自旋锁"><a href="#再谈自旋锁" class="headerlink" title="再谈自旋锁"></a>再谈自旋锁</h1><p>自旋锁是一种假设在不久将来，当前的线程可以获得锁，因此虚拟机会让当前想要获取锁的线程做几个空循环(这也是称为自旋的原因)，在经过若干次循环后，如果得到锁，就顺利进入临界区。如果还不能获得锁，那就会将线程在操作系统层面挂起，这种方式确实也是可以提升效率的。但问题是当线程越来越多竞争很激烈时，占用CPU的时间变长会导致性能急剧下降，因此Java虚拟机内部一般对于自旋锁有一定的次数限制，可能是50或者100次循环后就放弃，直接挂起线程，让出CPU资源。如下通过AtomicReference可实现简单的自旋锁。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class SpinLock &#123;</span><br><span class="line">  private AtomicReference&lt;Thread&gt; sign =new AtomicReference&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  public void lock()&#123;</span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    while(!sign .compareAndSet(null, current))&#123;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void unlock ()&#123;</span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    sign .compareAndSet(current, null);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用CAS原子操作作为底层实现，lock()方法将要更新的值设置为当前线程，并将预期值设置为null。unlock()函数将要更新的值设置为null，并预期值设置为当前线程。然后我们通过lock()和unlock来控制自旋锁的开启与关闭，注意这是一种非公平锁。事实上AtomicInteger(或者AtomicLong)原子类内部的CAS操作也是通过不断的自循环(while循环)实现，不过这种循环的结束条件是线程成功更新对于的值，但也是自旋锁的一种。</p>
<h1 id="CAS漏洞："><a href="#CAS漏洞：" class="headerlink" title="CAS漏洞："></a>CAS漏洞：</h1><p>CAS虽然很高效的解决原子操作，但是CAS仍然存在三大问题。ABA问题，循环时间长开销大和只能保证一个共享变量的原子操作</p>
<ul>
<li><p>从Java1.5开始JDK的atomic包里提供了一个类AtomicStampedReference来解决ABA问题。这个类的compareAndSet方法作用是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。<br>关于ABA问题参考文档: <a href="http://blog.hesey.net/2011/09/resolve-aba-by-atomicstampedreference.html" target="_blank" rel="noopener">http://blog.hesey.net/2011/09/resolve-aba-by-atomicstampedreference.html</a></p>
</li>
<li><p>循环时间长开销大。自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。如果JVM能支持处理器提供的pause指令那么效率会有一定的提升，pause指令有两个作用，第一它可以延迟流水线执行指令（de-pipeline）,使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。第二它可以避免在退出循环的时候因内存顺序冲突（memory order violation）而引起CPU流水线被清空（CPU pipeline flush），从而提高CPU的执行效率。</p>
</li>
<li><p>只能保证一个共享变量的原子操作。当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁，或者有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。比如有两个共享变量i＝2,j=a，合并一下ij=2a，然后用CAS来操作ij。从Java1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行CAS操作。</p>
</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="http://blog.csdn.net/javazejian/article/details/72772470" target="_blank" rel="noopener">http://blog.csdn.net/javazejian/article/details/72772470</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/02/26/egenie_business/manual-sql-separate-purchase-group/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Victor">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Victor的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/26/egenie_business/manual-sql-separate-purchase-group/" itemprop="url">手工合并采购单分组的sql</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-26T16:34:41+08:00">
                2018-02-26
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/02/26/egenie_business/manual-sql-separate-purchase-group/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/02/26/egenie_business/manual-sql-separate-purchase-group/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2018/02/26/egenie_business/manual-sql-separate-purchase-group/" class="leancloud_visitors" data-flag-title="手工合并采购单分组的sql">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">-- 查询出问题的采购单</span><br><span class="line">SELECT *</span><br><span class="line">FROM pms_purchase_order</span><br><span class="line">WHERE pms_purchase_order_no IN (&apos;CG2018-02100061021&apos;, &apos;CG2018-02100061023&apos;);</span><br><span class="line"></span><br><span class="line">-- 订单为主表,先将要处理的订单,抽出到一个表中</span><br><span class="line">CREATE TABLE `tmp_0226_mlj` AS</span><br><span class="line">  SELECT DISTINCT</span><br><span class="line">    sale_order_id,</span><br><span class="line">    &quot;XXXX&quot; AS group_no</span><br><span class="line">  FROM pms_daily_purchase_detail</span><br><span class="line">  WHERE pms_purchase_order_id IN (216606, 216608) AND single = 0;</span><br><span class="line"></span><br><span class="line">-- 由于create table的语法限制,如果 group_no 为null,无法进行update,so 先放一个长的字符串XXXX进去</span><br><span class="line">DESC tmp_0226_mlj;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- 手动更新组号</span><br><span class="line">UPDATE tmp_0226_mlj</span><br><span class="line">SET group_no = &apos;C&apos;</span><br><span class="line">WHERE group_no = &quot;XXXX&quot;</span><br><span class="line">LIMIT 200;</span><br><span class="line">UPDATE tmp_0226_mlj</span><br><span class="line">SET group_no = &apos;D&apos;</span><br><span class="line">WHERE group_no = &quot;XXXX&quot;</span><br><span class="line">LIMIT 200;</span><br><span class="line">UPDATE tmp_0226_mlj</span><br><span class="line">SET group_no = &apos;E&apos;</span><br><span class="line">WHERE group_no = &quot;XXXX&quot;</span><br><span class="line">LIMIT 200;</span><br><span class="line">UPDATE tmp_0226_mlj</span><br><span class="line">SET group_no = &apos;F&apos;</span><br><span class="line">WHERE group_no = &quot;XXXX&quot;</span><br><span class="line">LIMIT 200;</span><br><span class="line">UPDATE tmp_0226_mlj</span><br><span class="line">SET group_no = &apos;G&apos;</span><br><span class="line">WHERE group_no = &quot;XXXX&quot;</span><br><span class="line">LIMIT 200;</span><br><span class="line">UPDATE tmp_0226_mlj</span><br><span class="line">SET group_no = &apos;H&apos;</span><br><span class="line">WHERE group_no = &quot;XXXX&quot;</span><br><span class="line">LIMIT 200;</span><br><span class="line">UPDATE tmp_0226_mlj</span><br><span class="line">SET group_no = &apos;M&apos;</span><br><span class="line">WHERE group_no = &quot;XXXX&quot;</span><br><span class="line">LIMIT 200;</span><br><span class="line">UPDATE tmp_0226_mlj</span><br><span class="line">SET group_no = &apos;N&apos;</span><br><span class="line">WHERE group_no = &quot;XXXX&quot;</span><br><span class="line">LIMIT 200;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- 预览手动分配的组号</span><br><span class="line">SELECT</span><br><span class="line">  count(1),</span><br><span class="line">  group_no</span><br><span class="line">FROM tmp_0226_mlj</span><br><span class="line">GROUP BY group_no;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SELECT * from pms_daily_purchase_detail WHERE pms_purchase_order_id IN (216606, 216608) AND single = 0;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- 更新采购单明细</span><br><span class="line">UPDATE pms_daily_purchase_detail, tmp_0226_mlj</span><br><span class="line">SET pms_daily_purchase_detail.group_no = tmp_0226_mlj.group_no</span><br><span class="line">WHERE tmp_0226_mlj.sale_order_id = pms_daily_purchase_detail.sale_order_id</span><br><span class="line">      AND pms_purchase_order_id IN (216606, 216608) AND single = 0;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- 更新订单</span><br><span class="line">UPDATE sale_order, tmp_0226_mlj</span><br><span class="line">SET sale_order.group_no = tmp_0226_mlj.group_no</span><br><span class="line">WHERE tmp_0226_mlj.sale_order_id = sale_order.sale_order_id;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- 更新发货单</span><br><span class="line">UPDATE wms_order, tmp_0226_mlj</span><br><span class="line">SET wms_order.group_no = tmp_0226_mlj.group_no</span><br><span class="line">WHERE tmp_0226_mlj.sale_order_id = wms_order.sale_order_id;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/7/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/page/9/">9</a><span class="space">&hellip;</span><a class="page-number" href="/page/16/">16</a><a class="extend next" rel="next" href="/page/9/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Victor</p>
              <p class="site-description motion-element" itemprop="description">victor的个人博客,作为一枚后端开发工程师,写本博客目的,旨在记录自己在工作生活中的点点滴滴,形成自己的知识体系</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">157</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">27</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">77</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2017 &mdash; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Victor</span>
  
  <!--以下3行为一条竖线和Coding Page-->
  <div class="powered-by">
  </div>
  <span>Hosted by <a href="https://pages.coding.me" style="font-weight: bold">Coding Pages</a></span>
  
  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  

    
      <script id="dsq-count-scr" src="https://victor123-cn.disqus.com/count.js" async></script>
    

    

  




	





  














  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("QdvsGi5rrGt05B6T1cP9buCX-gzGzoHsz", "IPzdnLkdvxDPxh2zyHn82bWk");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  
  

  

  

  

</body>
</html>
